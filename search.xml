<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hello, Hexo]]></title>
    <url>%2Fhello-Hexo%2F</url>
    <content type="text"><![CDATA[寒假在家，用了一周时间，将博客又搬到了GitHub上，把typecho换成了对markdown支持更好的hexo，然后在搬文章的时候，顺手把所有的图片都托管到七牛云上，解决图片加载慢的问题。 设置DNS解析，国内用户解析到coding，国际用户解析到GitHub，达到加速的目的。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法求解N色方柱问题]]></title>
    <url>%2F%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%B1%82%E8%A7%A3N%E8%89%B2%E6%96%B9%E6%9F%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题简介设有n立方体，每个立方体的每个面用红、黄、蓝、绿等n种颜色之一染色。要把这n个立方体叠成一个方形柱体，使得柱体的4个侧面的每一侧均有n种不同的颜色。试设计一个回溯算法，计算出n个立方体的一种满足要求的叠置方案。例如：第一行有1个正整数n，0&lt;n&lt;27，表示给定的立方体个数和颜色数均为n。第2行是n个大写字母组成的字符串。该字符串的第k（0&lt;=k&lt;n）个字符代表第k种颜色。接下来的n行中，每行有6个数，表示立方体各面的颜色。立方体各面的编号如图所示： 上图中F表示前面，B表示背面，L表示左面，R表示右面，T表示顶面，D表示底面。相应的2表示前面，3表示背面，0表示左面，1表示右面，5表示顶面，4表示底面。结果输出：将计算的ｎ个立方体的一种可行的叠置方案输出到文件output.txt。每行6个字符，表示立方体个面的颜色。如果不存在所要求的叠置方案，输出“No Solution” 输入输出规范输入格式：n色方柱.txt:4R G B Y0 2 1 3 0 03 0 2 1 0 12 1 0 2 1 31 3 3 0 2 2 输出格式：solution.txt: 第1种立方体叠置方案为：R B G Y R RY R B G R GB G R B G YG Y Y R B B第2种立方体叠置方案为：G Y R B R RB G Y R R GR B B G G YY R G Y B B完成，共找到2种叠置方案。 算法策略事实上，N色方柱问题的解题思路很像N皇后问题的回溯算法思路，N皇后的要求是每放置一个皇后，使得已放置的皇后之间不能相互攻击。N色方柱的思路就是每放置一个立方体，使得已放置好的立方体柱四个侧面中每个侧面的颜色不重复。 首先已知两点： 一个立方体如果标记好相邻两个面，则能推导出所有面的标记。 立方体中相对的两个面永远固定。（比如：一个立方体前面为蓝色，后面为红色，则无论其怎么旋转，蓝色面和红色面永远是相对的） 由此，对每个涂完颜色的小立方体而言，一共有三组相对的面（前-后、左-右、上-下），而所需求解的立方体柱，只需要保证摆放完成的N个立方体，两组相对面（前-后、左-右）颜色不同即可。 下面开始对问题进行抽象：对于N个小立方体，首先构建N张无向图，每个图中，将N种颜色作为N个顶点，将三组相对面的颜色的顶点连成一条边，如图所示。 然后，将上述N个无向图合并，并标明每一条边来自哪个立方体，如图所示。 下一步在构成的无向图中，找出两个特殊子图。一个图表示叠置的N个立方体的前面和背面，另一个图表示叠置的N个立方体的左面与右面。同时构建子图时应满足三个性质： 每个子图有n条边，且每个立方体恰好一条边。 2个子图没有公共边。 子图中每个顶点的度均为2。 对于图中的无向图，找出满足要求的两个子图如图所示。 对图3中的两个子图，给定每条边一个方向，要求：每个顶点刚好有一个入度和一个出度。 至此，抽象求解完成，再根据构建的两个有向子图，映射出对应的立方体每个面的颜色。人为规定有向边的始点对应于堆叠完成的N个立方体的前面和左面，有向边的终点对应于堆叠完成的N个立方体的后面和右面。映射出的解如表。 F(前面) B(后面) L(左面) R(右面) Cube1 R B G Y Cube2 Y R B G Cube3 B G R B Cube4 G Y Y R 上述算法的关键是找到符合要求的两个子图，可以使用回溯法，类似于N皇后问题的求解思路。 数据结构选定对于输入的立方体颜色，使用board[N][6]二维数组进行存储，用color[N]一维数组存储颜色信息，对于构建好的子图，使用一个描述边的二维数组side[2][N]表示。其中有2行，一行描述一个子图，每一行中有N列，第N列表示第N个立方体选取的边的信息（一个立方体只能存在3组边，因此边的取值为0、1、2）。设定一个二维数组point[2][N]存储两个子图每条边的度（取值只能为0、1，不能超过2）。 在将子图转换为输出时，使用result[n][6]存储输出立方体的颜色信息（取值为0-n），used[n]存储边的使用情况（取值为0、1）。 求解步骤 定义问题的解空间 由问题理解可得，N色方柱问题的解空间为：一个可以存储两个子图的数据结构。在本题中为side[2][N]的二维数组（取值为0、1、2） 确定解空间的组织结构 确定显约束：每个子图有N条边且每个立方体提供一条边 搜索解空间 确定约束条件：每个子图有N条边且每个立方体提供一条边 确定限界条件：两个子图不存在公共边且构建完成后子图中每个顶点的度为2 使用全局变量board[N][6]存储立方体每个面的颜色信息，在回溯算法中，使用局部变量cube表示当前搜索的立方体，zitu表示当前构建的子图。使用point[2][N]记录两个子图中N个顶点的度（小于2），使用side[2][N]记录两个子图中选用的N个立方体的边的信息。首先遍历当前cube的side信息，找一条未使用过的边，若未找到，证明当前cube所有情况已经回溯完成，需要回溯到上一个cube寻找。若找到，接着将这条边对应的子图中的两个顶点的度分别加1，然后判断顶点的度是否大于2，若大于2，说明当前的cube的选边不合理，需要回溯重选；若小于2，再判断当前子图是否完成，若完成，开始查找下一个子图或输出结果，若未完成，则进入下一个cube继续搜索。]]></content>
      <categories>
        <category>tools</category>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>N色方柱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Biojava的安装与调试（Maven+idea）]]></title>
    <url>%2FBiojava%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B0%83%E8%AF%95%EF%BC%88Maven-idea%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言很久没有更新博客了，其实还是因为不知道该写点什么，最近跟着一个研究生学长在做项目，压力山大，收获颇丰。在做项目的过程中，我强制自己去看一些英语的论文，看GitHub的文档，Google一些官方API，感觉提升很大。最近会抽时间更新一些文章，一来做为备忘，以便随时回头查看；二来也算整理思路，在做项目时更有条理。 Biojava介绍Biojava官网（英文） Biojava是一个开源的生物信息学基础库，用于分析和表示生物序列（如DNA、RNA和蛋白质）的基础库。BioJava提供了生物序列处理功能（如转录与翻译）、文件格式转换功能和一些简单的科学计算（如隐马尔科夫模型）。 安装环境Windows10 + JDK8（Biojava官网说明只兼容JDK7或JDK8） 到我写这篇文章时，Biojava的最新版本号为4.2.0 根据官网介绍，可以使用Maven从Maven Central下载使用 Maven安装Maven是一个开源的Jar包管理工具，因此在安装之前应该确保Java环境（JDK）已安装。 1、 去Maven官网的下载页面下载最新版本的Maven的zip压缩包1apache-maven-3.5.4-bin.zip 2、 在本地解压后，将目录（下文简称 %PATH%）新建到系统环境变量MAVEN_HOME中 1e.g: C:\tools\apache-maven-3.5.4 在系统环境变量PATH中追加%MAVEN_HOME%\bin 3、 更改maven仓库位置（default：%USER%.m2\maven_repository）不想改的转4。 在目标位置新建文件夹maven_repository，该目录为maven的本地库。打开%PATH%\conf\settings.xml文件，找到1&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; 将其移动至注释外，并将中间内容改为自定义的maven_repository目录地址。e.g:1&lt;localRepository&gt;C:\tools\maven_repository&lt;/localRepository&gt; 4、 添加阿里云的maven镜像源为主镜像。在%PATH%\conf\settings.xml文件中找到123&lt;mirrors&gt;...&lt;/mirrors&gt; 在中间插入以下代码并保存： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; 5、 运行DOS命令mvn -v查看maven是否正常安装，mvn help:system在库中自动下载索引文件 idea中配置在setting中找到Build-&gt;Build Tools-&gt;Maven修改Maven home directory和User settings file选项。 如果有需要可以在importing-Automatically download:中将Sources和Documentation勾选，方便以后找源码和demo 然后可以新建一个maven空项目，在Biojava的GitHub界面中，介绍了快速添加Biojava的方法. 在项目的pom.xml文件中，加入代码： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.biojava&lt;/groupId&gt; &lt;artifactId&gt;biojava-core&lt;/artifactId&gt; &lt;version&gt;5.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- other biojava jars as needed --&gt; &lt;/dependencies&gt; 之后idea会提示更新maven文件，更新完成后就可以使用了。 在程序编译时，idea可能会报Warning提示：IntelliJ IDEA 源值1.5已过时，将在未来所有版本中删除。 这是因为IDEA默认把项目的源代码版本设置为jdk1.5，目标代码设置为jdk1.5，最直接的方法是在项目的pom.xml文件中添加 12345&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt; 其他方法比如修改setting.xml文件、设置项目的Modules的Language Level 为“8”都可以。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记1]]></title>
    <url>%2FPython%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[类和对象类是抽象的模板，而实例是根据类创建出来的一个个具体的对象，每个对象都拥有相同的方法，但各自的数据可能不同。在python中，定义类是通过class关键字：12class Student(object): pass class后面跟着的是类名，一般为大写开头的单词，括号中的object表示该类是从哪个类继承下来的，默认的为object，这是所有类最终都会继承的类，和Java类似。 定义好了Student类，就可以根据Student类创建出Student实例，创建实例是通过类名+()实现的。12345&gt;&gt;&gt;test = Student()&gt;&gt;&gt;test&lt;__main__.Student object at 0x10a67a590&gt;&gt;&gt;&gt;Student&lt;class '__main__.Student'&gt; 可以看出，变量test指向的是一个Student实例，后面的十六进制为内存地址，每个object的地址都不一样。 和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。123456789&gt;&gt;&gt;test1 = Student(&apos;Xiao Fang&apos;, 80)&gt;&gt;&gt;test2 = Student(&apos;Xiao Ming&apos;, 90)&gt;&gt;&gt;test1.age = 19&gt;&gt;&gt;test1.age19&gt;&gt;&gt;test2.ageTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;age&apos; __init__通过init方法，可以在创建实例的时候，把一些必须绑定的属性强制填写进去。12345class Student(object): def __init__(self,name,score): self.name = name self.score = score 其中init方法的第一个参数永远是self，表示创建的实例本身，因此在init方法内部，就可以把各种属性绑定到self。 有了init方法，在创建实例的时候，就不能传入空的参数了，必须传入与init方法匹配的函数，但self不用传。12345&gt;&gt;&gt;test = Student('Xiao Fang', 80)&gt;&gt;&gt;test.name'Xiao Fang'&gt;&gt;&gt;test.score80 私有变量为了使类的内部属性不被外部访问，可以把属性的名称前加上两个下划线，在Python中，实例的变量名如果为****开头，就变成了一个私有变量（private），只有内部可以访问，外部不可以访问。12345678class Student(object): def __init__(self,name,score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 修改完成后，就不能在外部访问name和score了。这是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。12&gt;&gt;&gt;test._Student__name&apos;Xiao Fang&apos; 但Python官方并不建议用户这么做，因为不同版本的Python解释器会把__name改成不同的变量名。 然而，在Python中，变量名类似xxx的，为特殊变量，虽然是以双下划线开头，但可以直接访问，不是private变量。 而以单下划线开头的实例变量名，如_name外部是可以访问的，但是按照约定俗成，要将其视为私有变量，不要随意访问。 __slots__Python允许用户在创建类的实例后，给该实例绑定任何属性和方法。但给一个实例绑定的方法，对其他实例是不起作用的。为了给所有实例绑定方法，可以直接为class绑定该方法。1234&gt;&gt;&gt;def set_score(self, score):... self.score = score...&gt;&gt;&gt;Student.set_score = set_score 这时，所有的以Student类创建的实例都可以调用set_score方法。 为了限制实例的属性，Python允许在定义class的时候，定义一个特殊的 slots变量，来限制该class实例能添加的属性。12class Student(object) __slots__ = ('name', 'age') 然后就只能对Student实例添加name和age属性。 需要注意的是，slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。 继承基本方法当定义一个class时，可以从现有的某个class继承，新的class称为子类，而被继承的class称为父类、基类。123456789class Animal(object): def Run(self): print('Animal is running ...')class Dog(Animal): passclass Cat(Animal): pass 对于Dog和Cat来说，Animal就是他的父类，对于Animal来说，Dog和Cat都是他的子类。子类可以获得父类的全部功能。由于Animal实现了Run（）方法，因此，Dog和Cat也都自动拥有了Run（）方法。 为了对Dog和Cat的Run（）方法加以区分，可以对代码进行一点修改。1234567class Dog(Animal): def Run(self): print('Dog is running ...')class Cat(Animal): def Run(self): print('Cat is running ...') 当父类和子类都存在相同的Run（）方法时，子类的方法会覆盖掉父类的方法。在代码运行时，总会调用子类的Run（）方法。 多重继承不同与单一继承的语言（如Java），Python中可以通过多重继承，使一个子类可以同时获得多个父类的全部功能。12345678910class Runnable(object): def Run(self): print('Running ...')class Animal(object): def Live(self): print('living ...')class Dog(Animal, Runnable): pass 多态基本方法在说明多态之前，先添加一个函数，这个函数接受一个Animal类型的变量。123def Run_twice(Animal): Animal.Run() Animal.Run() 原代码为：1234567891011class Animal(object): def Run(self): print('Animal is running ...')class Dog(Animal): def Run(self): print('Dog is running ...')class Cat(Animal): def Run(self): print('Cat is running ...') 当传入Animal的实例时，Run_twice()就打印出12Animal is running ...Animal is running ... 当传入Dog的实例时，Run_twice()就打印出12Dog is running ...Dog is running ... 可以看出，对于任何一个Animal的子类，任何依赖Animal作为参数的函数或方法都可以不加修改的正常运行。这就是多态。 对于一个变量，我们只需要知道它是Animal类型，无需确切知道他的子类型，就可以调用Run（）方法。当我们新增一个Animal的子类时，只要确保Run（）方法编写正确，不用管原来的代码是如何调用的，这样也符合面向对象编程中的开闭原则。（对扩展开放：允许新增Animal子类。对修改封闭：不需要依赖Animal类型的Run_twice()函数） 鸭子类型对于静态语言（C++，Java等）来说，如果需要传入Animal类型，则传入的对象就必须是Animal类型或者它的子类，否则将无法调用Run（）方法。对于python来说，不一定需要传入Animal类型，只需要保证传入的对象有一个Run（）方法就可以了。123class Timer(object) def Run(self) print('Start ...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的 总结类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。]]></content>
      <categories>
        <category>tools</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界不美丽，但是我爱你]]></title>
    <url>%2F%E4%B8%96%E7%95%8C%E4%B8%8D%E7%BE%8E%E4%B8%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[我本想这个冬日就去死的，可正月里有人送了我一套鼠灰色细条纹的麻质和服作为新年礼物。是适合夏天穿的和服，那我还是先活到夏天吧 ——太宰治《叶》 我时常觉得自己没有任何厌世的资格。 我的家庭和睦，父母没有经常给我不愉快的感受；我家境普通，但也不愁温饱；我有关系很好的朋友，也向往美好真挚的爱情；我从未受过欺凌，也没经历过多么绝望的事；我身体健康，不高不丑不胖不帅；我也像大多数人一样，一路读书读到这里。 世界待我尚可，我什么也不缺，但也会像什么也没有一样。 我过着尚可的日子，每天都觉得我用掉的时间，仿佛毫无意义。 没有经历过救亡图存的爱国热血，没有能力和机遇去做什么伟大的事情，没有世界末日，没有小说里精彩曲折的故事…… 没有疯狂，没有奔跑，没有非如此不可，没有坚定不移的终极目标。 从我小时候，知道了人是进化出来的动物，知道了人类在宇宙中的渺小后，我就渐渐明白。 “创造人类的世界，并没有给人类任何意义，一切只是条件的符合而已，人生的意义全部是人类自己定义的。” 我开始怀疑一切，怀疑所有正确的答案，怀疑一眼看到头的主流路线……我曾经去看了很多对于人生意义的解释，但几乎全都是自欺欺人之法，直到今天我才明白，接受人生的没有意义，正是可以真正追求意义的第一步。这个世界残酷且黑暗，我们要去热爱它，两者并不矛盾。 世界不美丽，但是我爱你。 正是因为没有意义，才可以赋予给自己意义。 世界缓慢而坚定的向前推进，我们在历史的车辙中只是蝼蚁，但历史从来没说过：蝼蚁不能有自己的快乐。 自事其心者，哀乐不易施乎前，知其不可奈何而安之若命，德之至也。 世人可爱，世事可戏。 以上。]]></content>
      <categories>
        <category>方方说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++中vector的常用方法]]></title>
    <url>%2FC-%E4%B8%ADvector%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言在C++中，vector是一个十分有用的容器。它能像容器一样存放各种类型的对象，简单来说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。相较链表而言，vector中提供了大量的方法供直接使用，降低了代码复杂度，也提高了易读性。 注意：vector相较于链表，实现插入和删除操作时效率较低，当动态添加的数据超过系统所分配的默认内存大小时，要进行整体的重新分配、拷贝和释放。 实例基本操作1. 头文件1#include&lt;vector&gt; 2. 创建vector对象1vector&lt;int&gt; test; 3. 尾部插入12int a = 0;test.push_back(a); 4. 使用下标访问元素1test[0] = 1; 5. 插入元素1test.insert(test.begin()+i, a); //在第i+1个元素前插入a 6. 删除元素1test.erase(test.begin()+3); //删除第3个元素 7. vector向量大小1test.size(); 8. 清空1test.clear(); begin与end函数、front与back函数的差别说明 begin()：返回当前vector容器内起始元素 end()：返回当前vector容器内末尾元素 front()：返回当前vector容器中起始元素的引用 back()：返回当前vector容器中末尾元素的引用 e.g12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; test; vector&lt;int&gt;::iterator i1; vector&lt;int&gt;::iterator i2; test.push_back(1000); test.push_back(1001); test.push_back(1010); test.push_back(1011); cout &lt;&lt; "front()=" &lt;&lt; test.front() &lt;&lt; endl; cout &lt;&lt; "back()=" &lt;&lt; test.back() &lt;&lt; endl; i1 = test.begin(); i2 = test.end()-1; //end()向的是最后一个元素的下一个位置，因此想要访问最后一个元素的正确操作为：end()-1 cout &lt;&lt; *i1 &lt;&lt; endl; cout &lt;&lt; *i2 &lt;&lt; endl; return 0;&#125; 输出结果front()=1000back()=101110001011 算法（1）reverse需要头文件： #include用法： reverse(test.begin(), test.end()); 将元素翻转，即逆序排列。 （2）sort需要头文件： #include用法 ： sort(test.begin(), test.end());默认为升序排列，即从小到大。用法：12345bool cmdPaixu(int a, int b)&#123; return a&gt;b;&#125;sort(test.begin(), test.end(), cmdPaixu); 重写排序比较函数，实现降序排列。]]></content>
      <categories>
        <category>tools</category>
        <category>code</category>
      </categories>
      <tags>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在逛超市，没空想标题]]></title>
    <url>%2F%E6%88%91%E5%9C%A8%E9%80%9B%E8%B6%85%E5%B8%82%EF%BC%8C%E6%B2%A1%E7%A9%BA%E6%83%B3%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[小区外面新开了一个超市，名字很古怪，叫“万有市集”。虽然店面很小，但人们总能在里面找到自己想买的东西。 付款的方式也很特别，用光阴换物品。支付一天寿命可以换一本书，一个月可以换一套好看的衣服，一年能换郊区的一套小小的商品房。 最为奇特的是，店内只有一个常年带着兜帽的店主，但货物总是可以摆放整齐，地面也一直十分洁净。可能因为他总坐在角落里，小区里没人看到过他的脸。 店铺刚开业时，总有些胆子大的人来尝试。开始只是小打小闹，买一些零食，几条烟，日常的一些蔬菜瓜果。结账时，店主伸出他苍白细长的手指在人们的眉心一点，一点白光闪过后，光阴付款就完成了。当人们拿的东西没多少钱时，店主甚至完全不搭理你，不耐烦的挥手赶你走。 渐渐的，人们发现自己的身体并没有什么变化，他们开始认为店主在故弄玄虚，是一个疯子。但由于人们总是能找到心心念的商品，小小的“万有市集”开始门庭若市。 小明在大学毕业后租房在这座小区做起了微商。可惜她并没有那么好运赶上微商的浪潮，只能奋力向前去仰望羡慕那些踏浪前行的弄潮儿。 看着自己的同行在朋友圈每天都在晒着各种自拍、美食、奢饰品，自己却只能蜷缩在城市郊区的陋巷，为每日的温饱和客户赔笑脸。无名的焦虑感每日都在增强，嫉妒也让她惶惶不可终日。 她意识到，只有身份才能改变这一切。没有一些背景，也没有很多资产，别人凭什么相信你，凭什么放心把货物让你来代理。只有年轻人才把热情和奋斗当作资本，在别人眼里，这些一文不值。 下定决心的她，打算玩一票大的。 万有市集依旧人来人往，人们在觉得店主是疯子后，非但没有同情，反而更加频繁来这里“购买商品”。 小小的店面里每天都挤满了来抢购的人，可不管人们怎么拿，货物好像都拿不完的样子。人们从未看到过店主进货，也没有见过有人来打扫卫生，但店面每天都整洁如新。 每一个觉得自己占到便宜的人在走出店门的时候，脸上都挂着灿烂的笑意，可很少有人能注意到笑容的眼角上悄然出现的几条皱纹。也没人注意到人声鼎沸的小店里渐渐有点阴冷起来。 小明挤进店里，四处闲逛后，看见了一辆豪车的车钥匙，标价10年。这正是她梦寐以求的身份的象征。又挑了一些零食后，小明走向了收银台。 这是万有市集第一次销售如此巨额的商品，连店主在看到车钥匙的时候都明显愣了一下，抬头看了看小明。这是他第一次抬头看向顾客，可由于光线和兜帽的遮挡，他的脸依然隐藏在黑暗之中，只有猩红色的瞳孔，透漏出狡黠的目光，让小明不寒而栗。 “一共10年，零头不算了。” 一点白光闪过，小明明显感到，店主的手指竟多了一点温度，也多了一丝肉色。 “车子在小区车库里，自己去拿。”说完递给小明一张车库门牌号。 这就好了？我竟然骗了他一百多万？我要不要去警察局自首？小明做贼心虚般匆匆忙忙离开了小店，“万有市集”这四个大字在她看来是如此的刺眼，可她还未曾发现，招牌下面，还有一行小字…… “祝贺‘今天要卖货团队’创始人明总，喜提劳斯莱斯。明总加入微商五个月，微商新女性，左手事业，右手家庭……” 朋友圈里同行的点赞纷至杳来，请她代理的商家也慢慢变多。她的团队再也不是一个人了，她开始招助理，发展下线，甚至为了更大的利益，在违法的边缘试探。 她并不担心警察来抓她，因为她早已经在万有市集中，花20年的光阴，买下了美国绿卡和旧金山的多处豪宅。 她渐渐依赖小店了，她觉得不能没有小店，她想从这里榨取更多的利益……就像她第一次提车时那样。 她开始注重保养皮肤，虽然才30岁，但眼角的皱纹已经怎么也遮不住了。无奈的她只好飞去韩国接受了整形手术。 直到有一天，质检总局接到举报说小明卖的商品有质量问题。调查组立即开始调查，冻结了小明的所有资金，并限制她购买逃向美国的机票。 小明迫不得已再一次来到了小店。这里依旧人满为患，只是最开始来买商品的大爷大妈都不见了，店里多了许多陌生的新面孔。 虽然是盛夏，店里没有空调，却时不时吹出一阵阵冷风，令人毛骨悚然。 小明看到了她需要的假身份证和机票，又顺手拿了一些奢饰品和几套名贵服装。 结账的时候，店主看了看小明，说：“对不起，你的余额不足了。” 说完还没等小明回过神来，店主那只比正常人略微修长的手指便点向她的眉心，一阵白光后，小明消失在原地，周围的人却仿佛什么也没有发生过。 小明只觉得一阵晕眩，接着身体开始透明，她穿过了其他人的身体，她大声哭喊，可没人看得见，也没人听得见，仿佛她被隔绝在了平行宇宙的另一端，除了一个人。 店主缓缓站起来，摘掉兜帽。 “你阳寿已尽，黑白无常只会在勾魂簿记载的日子里才能来，这些年你支付的光阴，就在这里工作来偿还吧。” 小明看向四周，看到了不少熟悉的身影，那是最开始的一群大爷大妈。他们仿佛已经被折磨的失去了灵魂，在小店里默默打扫，摆放货物…… 万有市集依旧开着，人们从五湖四海赶过来，只为了占这必定要还的便宜。 万有市集招牌下方的小字，鲜有人看到，上面写着 “一寸光阴一寸金，寸金难买寸光阴。”]]></content>
      <categories>
        <category>方方说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题（C++）]]></title>
    <url>%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88C-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是八皇后问题？八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出： 在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法? 如何解决八皇后问题？解决八皇后问题，核心就在于递归回溯。所谓递归回溯，本质上是一种枚举法。这种方法是从棋盘的第一行开始尝试摆放第一个皇后，排放成功后递归一层；再遵循规则在第二行摆放第二个皇后，如果当前位置无法摆放，则向右一格再次尝试；如果摆放成功，则继续递归一层…… 下面我会用不太抽象的代码详细讲解 八皇后问题的代码实现解决八皇后问题可以分为两个层面： 找出一种解，即深度优先遍历。 找出全部解，即广度优先遍历。 这两种方法在代码模块上区别不是很大，只用更改递归回溯的方法即可在上面两个解上切换。 在写代码之前，我们需要解决几个问题 1. 国际象棋的棋盘怎么表示？用一个8*8的二维数组表示即可。123#define N 8 //棋盘格子的范围int count = 0; //解的个数int chess[N][N] = &#123;0&#125;; //棋盘 这里使用int数组，初始值为0，当此位置有皇后放置时，对应的元素置1。 例如： chess4就代表第5行第6列。 2. 如何判断皇后的落点是否符合规则？可以定义一个check函数，传入皇后的落点，通过对当前行之前的纵向和斜向是否存在其他皇后来判断。12345678910bool check(int x, int y)&#123; for (int i=0; x-i &gt;= 0; i++) &#123; if (chess[x-i][y]==1) return false; //检查纵向 if (y-i &gt;= 0 &amp;&amp; chess[x-i][y-i]==1) return false; //检查左斜向 if (y+i &lt;= N &amp;&amp; chess[x-i][y+i]==1) return false; //检查右斜向 &#125; return true;&#125; 3. 如何将结果输出？可以定义一个print函数，遍历整个二维数组并输出就可以。1234567891011121314void print()&#123; cout &lt;&lt; "第" &lt;&lt; count &lt;&lt; "组" &lt;&lt; endl; cout &lt;&lt; "******************" &lt;&lt; endl; for(int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; cout &lt;&lt; chess[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; "******************" &lt;&lt; endl;&#125;; 4. 如何进行递归回溯？递归回溯是这个问题的核心，对于开始提出的两个解，分别应用两种递归思路。 （1）找出一种解递归算法：123456789101112131415161718192021bool settle(int x)&#123; //行数超过，即表明找到正确答案 if (x==N) return true; //遍历当前行，逐一验证 for (int i = 0; i &lt; N; i++) &#123; // 为当前行清零，防止出现脏数据 for (int j = 0; j &lt; N; j++) chess[x][j]=0; // 检查是否合规 if (check(x, i)) &#123; // 合规则放置皇后 chess[x][i] = 1; // 进行下一行递归 if (settle(x+1)) return true; &#125; &#125; return false;&#125;; 主程序：123456int main()&#123; settle(0); print(); return 0;&#125; 输出结果： （2）找出所有解递归算法：1234567891011121314151617181920212223242526272829void settle(int x)&#123; // 遍历当前行，逐一验证 for (int i = 0; i &lt; N; i++) &#123; // 检查是否合规 if (check(x,i)) &#123; // 合规则放置皇后 chess[x][i] = 1; // 若为最后一行，则解数加一，打印结果，并清除当前行数据 if (x == N-1) &#123; count++; print(); chess[x][i] = 0; return; &#125; // 若不为最后一行，则进行下一行递归 else &#123; settle(x+1); &#125; &#125; // 清除脏数据 chess[x][i] = 0; &#125; return;&#125;; 主函数：1234567int main()&#123; settle(0); cout &lt;&lt; endl; cout &lt;&lt; "共" &lt;&lt; count &lt;&lt; "组" &lt;&lt;endl; return 0;&#125; 输出结果（部分） 一些思考由结果已知，八皇后问题一共有92种解法，棋盘为正方形，可进行4次90°旋转，所以不重复的解应该有92/4=23种，如果能用程序找出这23种解法，并进行4次旋转，时间复杂度会比当前简单很多。 在查资料的时候，据说使用位运算会简单很多，有时间看看。 附一个有趣的链接：如何用C++在10行内写出八皇后？- 知乎]]></content>
      <categories>
        <category>tools</category>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长安客]]></title>
    <url>%2F%E9%95%BF%E5%AE%89%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 有多少人和我一样，坐在不足十平米的空间里，看着书里九万五千公里的绚丽。又或是和我一样，拥有一颗比九万五千公里还辽阔的心，却坐在不足一平米的椅子上。——《不去会死》 第一次听说长安，是小学在哥哥家看《童话世界》，他们的编辑部就在西安。想着有机会要去亲自拜访，把没有买到的期刊补全，却一直没去。 后来机缘巧合之下跟着旅行社来到了西安，在兵马俑、华清池、大雁塔兜兜转转，也没有去成《童话世界》的编辑部。待到大些时候，再来西安，却过了那个童话的年纪。 考到陕西上大学后，每次来西安都有着各种稀奇古怪的事情要办，我好像提前进入了上班族的行列，带着耳机和漠不关己的眼神，匆匆的走在这里，好像要和汽车赛跑，以此来感受城市的快节奏生活。临走前还不忘抱怨： “呸，这里真tm冷漠。” 但这次的西安两日之旅，让我对这座城市的印象大为改观。 这是一个需要你亲自来体验才懂的城市，这是一座你来了便不会忘了的历史之都。 小公交 有人说，到一个地方旅游，重要的不是风景，而是当地的人。景由心生，但人由景生。一方水土养一方人。陕西人的直爽我已经领教了两年，这次来到西安，却发现了西安人独有的好客和热心，在这里，司机不是抢时间而是让着行人的，公交车是不需要喊师傅停车而是每站必停的。可能因为这次是抱着旅游的心态吧，人也由心生。 但最让我印象深刻的是照片里的这种小公交车，一个只有9个座位的小公交。在引擎的轰鸣下晃晃悠悠的走着，有着和大公交不一样的悠闲和自由。 大唐芙蓉园 著名的景点周围总是不缺乏排队的人群，即使今天是清明。 小时候也从未见过有哪一个景点的排队人数有如今之多，即使是以前的长城和天安门。可能人们的生活水平真的提高了不少吧。另外，手机在排队中的作用也至关重要。 小时候人们排队时无外乎聊天和发呆，时间过的很慢，人的耐心总是有限度的，队伍也就长不起来。现在排队的时候大部分人都在低头看手机，一来能排遣无聊的等待时间，二来手机确实很好玩。 在芙蓉园中，经常能看到很多现代和古代融合的奇景。钢铁之躯的脚踏船外是木船的装饰、钢筋混凝土的亭台外是仿朱砂的漆、古色古香的阁楼外挂着恢宏的牌匾和同样经历风吹雨打的空调外机。 人们来到这里，想梦回大唐，却离不开现代科技的便利。匆匆走过各个景点，用自拍杆记录下今昔俊俏的容颜，再配上几句伤感的诗词，我们成功的在各大社交平台梦回“长安”。 现在在展出的文物面前停留最多的，不是眼睛，而是镜头和闪光灯。 科技的进步让我们可以长久保存事物的影像。在景区，博物馆，动物园，人们举着相机，手机疯狂拍摄。有一些人是真的在寻找景物特定的美，而绝大多数人，来到一处，闪光灯一阵乱闪，便匆匆走向下一处，这些照片可能他再也不会看，只有在手机提示内存不足时，“选择”-“删除”-“确定”。 小时候，老一辈人在聊到一个地方时，他们会说：“这里的XX挺棒的，有XX，XXX……特别好看!” 当我们聊到一个地方的时候，我们总会兴奋的说：“这里我来过！”接着便掏出手机，迫不及待展示自己行云流水的拍摄成果。 相比这样，我更热衷于仔细欣赏我喜欢的作品，然后任它们在记忆中被渐渐遗忘。当再次提起时，能留有一份欣赏时的韵味。 说有一位画家，在沙滩上用棍子画了一副惊世之作，接着便欣赏它在涨潮时慢慢消失。《月亮与六便士》中的主人公最后命令也家人烧掉了自己画有传奇作品的屋子。 可以说，艺术的美，就在与它被人们遗忘时的心痛感。 艺术真残酷。 曲江书城 上一次正儿八经去图书馆看书已经是初中时候了吧，高中无暇看书，偷偷看本读者，心里都美滋滋，哪有功夫看书。 在大学里，生活上的事情处理的一团遭，忙的焦头烂额，游戏又那么好玩。 一进门，我的身心都渐渐安静下来，在一排排书中行走，看着琳琅满目的书名，颇有种古代黄帝翻牌子的快感。一时不知道从何下手。 在电子书大行其道的当日，我们却很少去重复读一本书。匆匆看完后，“唉”一声，又打开了下一本。然而书对于我们这种记忆力正常的人类来说，是需要反复读的，反复读的好处，这里就不过多赘述，自己百度吧。 永兴坊 西安的夜市就属回民街最热闹，然而西安的同学告诉我，那都是你们外地人去的，我们才不去。然后我就来到了本地人去的小吃街。 可能人们都学聪明了吧，这里的人比起回民街竟然过而不及。在摩肩接踵的人流中，我的腰包竟然也迅速变瘪。我这才发现，明明食物没有多美味，在拥挤的环境中，我不知不觉买了快￥100的小吃，放在外面可能不到￥40，颇有回民街的风采。 那为什么还有这么多人来？可能是为了图个热闹。 在人云亦云的环境里，我们要做出自己的判断，真的比想像中还要难。 长安客和胡辣汤 走之前看的几个酒店在中午的时候都被订完了，我们阴差阳错的选择了这个离景点数公里的酒店，条件很棒也不算贵。名字很值得品味，总觉得比什么凯旋酒店之流好上太多，可能是没钱也要鄙视一下的心理在作祟。 踏破铁鞋无觅处，柳暗花明又一村。 早上办理完退房手续，刚出酒店门，就看到了一家正宗的河南胡辣汤店。感动。 在陕西的两年，我和其他河南人一样，忘不了那一碗胡辣汤。然而这里最多的却是一种叫做：肉丸胡辣汤的怪异种。为了那种味道，我找了两年，失望了一次又一次，却在不经意的一次回头，闻到了熟悉又陌生的香味。 在我每次特别想要一个东西时，好像我在和全世界作对。但世界却时不时把这些东西看似随意的丢给我，好像是我完成某些指定动作的奖励。 剁椒鱼头 在这的最后一顿饭，是西安的同学请客，选的是一家湘菜馆。一道剁椒鱼头吃的我欲罢不能。 辣椒其实并不是我国的本土作物，据说是在唐宋时期，洋人作为观赏植物朝贡而来。伟大的天朝人民却发现了这种不同寻常的味道可以用来入菜。 其实辣是一种痛觉。在我看来，流着眼泪也要吃辣是十分伤心时才会做的事，这样就可以让人看不到自己其实是哭出的泪，不然何必要让自己疼呢。就好像杀手就算在白天杀人还要穿黑衣，也是为了不让对方看出自己的伤口。 其实人们吃辣上瘾是有原因的。人们在受到刺激的时候，会分泌一些物质来自我麻痹进而达到保护自身的目的。这些物质会让人产生一种飘飘欲仙的快感。吃辣刺激了身体进行自我麻痹，从而产生快感。 不管你是谁，受到刺激的时候身体的第一反应就是逃避。 结语旅行让我们明白，原来我们的生活如此可以轻而易举的改变，数天的旅程，来到一个陌生的地方，没人知道你叫什么，好像什么都可以重新开始，陌生给予我们不安而又奇特的安全感。站在人潮涌动的街头，擦肩而过，给予彼此空洞的一瞥，有时却有些莫名的感动。]]></content>
      <categories>
        <category>方方说</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式（Abstract Factory）]]></title>
    <url>%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、 前言在上文中介绍的工厂方法模式（Factory Method）中，有一些问题尚未解决。 每次增加一个产品时，都需要增加一个具体类和对象实现工厂。 而在现实生活中，一个工厂往往要生产很多种类的产品，为了解决上述的问题，我们又使用了一种新的设计模式——抽象工厂模式（Abstract Factory）。 在阅读下文前强烈建议先阅读：设计模式简介简单工厂模式（Simple-Factory）工厂方法模式（Factory Method） 二、 介绍1. 定义抽象工厂（Abstract Factory）模式为创建一组相关或相互依赖的对象提供一个接口，而不需要指出用于创建对象的具体类。 2. 解决的问题每次增加一个产品时，都需要增加一个具体类和对象实现工厂。（即工厂方法模式的缺点） 3. 和工厂方法模式的对比(1) 不同点 工厂方法模式 抽象工厂模式 针对的是一个产品等级结构 针对的是面向多个产品等级结构 一个抽象产品类 多个抽象产品类 可以派生出多个具体产品类 每个抽象产品类可以派生出多个具体产品类 每个具体工厂类只能创建一个具体产品类的实例 每个具体工厂类可以创建多个具体产品类的实例 最主要的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一个种类。 (2) 相同点 一个抽象工厂类，可以派生出多个具体工厂类 三、 模式原理1. UML类图 2. 使用步骤 创建抽象工厂类，定义具体工厂的公共接口； 创建抽象产品族类 ，定义抽象产品的公共接口； 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口； 创建具体产品类（继承抽象产品类） ，定义生产的具体产品； 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法； 客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例。四、 实例&amp;代码1. 基本情况 背景：小X有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂也需要生产模具类产品，B厂也需要生产容器类产品。 冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂（无法使用工厂方法模式） 解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。2. 使用步骤(1) 创建抽象工厂类，定义具体工厂的公共接口1234abstract class Factory&#123; public abstract Product ManufactureContainer(); public abstract Product ManufactureMould();&#125; (2) 创建抽象产品族类 ，定义抽象产品的公共接口123abstract class AbstractProduct&#123; public abstract void Show();&#125; (3) 创建抽象产品类 ，定义具体产品的公共接口123456789//容器产品抽象类abstract class ContainerProduct extends AbstractProduct&#123; public abstract void Show();&#125;//模具产品抽象类abstract class MouldProduct extends AbstractProduct&#123; public abstract void Show();&#125; (4) 创建具体产品类（继承抽象产品类）， 定义生产的具体产品123456789101112131415161718192021222324252627//容器产品A类class ContainerProductA extends ContainerProduct&#123; public void Show() &#123; System.out.println("生产出了容器产品A"); &#125;&#125;//容器产品B类class ContainerProductB extends ContainerProduct&#123; public void Show() &#123; System.out.println("生产出了容器产品B"); &#125;&#125;//模具产品A类class MouldProductA extends MouldProduct&#123; public void Show() &#123; System.out.println("生产出了模具产品A"); &#125;&#125;//模具产品B类class MouldProductB extends MouldProduct&#123; public void Show() &#123; System.out.println("生产出了模具产品B"); &#125;&#125; (5) 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法123456789101112131415161718192021//A厂 - 生产模具+容器产品class FactoryA extends Factory&#123; public Product ManufactureContainer() &#123; return new ContainerProductA(); &#125; public Product ManufactureMould() &#123; return new MouldProductA(); &#125;&#125;//B厂 - 生产模具+容器产品class FactoryB extends Factory&#123; public Product ManufactureContainer() &#123; return new ContainerProductB(); &#125; public Product ManufactureMould() &#123; return new MouldProductB(); &#125;&#125; (6) 客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例1234567891011121314151617//生产工作流程public class AbstractFactoryPattern &#123; public static void main(String[] args)&#123; FactoryA mFactoryA = new FactoryA(); FactoryB mFactoryB = new FactoryB(); //A厂当地客户需要容器产品A mFactoryA.ManufactureContainer().Show(); //A厂当地客户需要模具产品A mFactoryA.ManufactureMould().Show(); //B厂当地客户需要容器产品B mFactoryB.ManufactureContainer().Show(); //B厂当地客户需要模具产品B mFactoryB.ManufactureMould().Show(); &#125;&#125; (7)结果1234生产出了容器产品A生产出了模具产品A生产出了容器产品B生产出了模具产品B 五、 优缺点1. 优点 降低耦合。抽象工厂模式将具体产品的创建延迟到子类具体工厂中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展。 抽象工厂模式隔离了具体类的生成。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 更符合开放封闭原则。新增一种产品族时，只需要增加相应的具体产品类和相应的工厂子类即可。2. 缺点 抽象工厂模式很难支持新种类产品的变化。 这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象层的代码，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了开放封闭原则。 也就是说：在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开放封闭原则的倾斜性。 六、 应用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程。 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。]]></content>
      <categories>
        <category>tools</category>
        <category>OOAD</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式（Factory Method）]]></title>
    <url>%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Method%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、 前言在上文中介绍的简单工厂模式（Simple-Factory）中，有一些问题尚未解决。 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响。 违背开放封闭原则，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 为了解决这些问题，需要使用一种新的设计模式————工厂方法模式（Factory Method）。 在阅读下文前强烈建议先阅读设计模式简介简单工厂模式（Simple-Factory） 二、 介绍1. 定义通过定义一个用于创建对象的接口，让子类决定具体实例化哪个产品类，工厂模式使其创建过程延迟到子类进行。工厂方法模式又称为：工厂模式(Factory Pattern)、虚拟构造器模式(Virtual Constructor Pattern)、多态工厂模式(Polymorphic Factory Pattern)等。 2. 解决的问题解决了工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，遵守了“开放封闭原则”。 之所以能解决简单工厂的问题，是因为工厂方法把具体产品的创建推迟到工厂的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只给出具体工厂必须实现的接口，符合开放封闭原则。 三、 模式原理1. UML类图 2. 模式组成 组成（角色） 关系 作用 抽象产品（Product） 具体产品的父类 描述具体产品的公共接口 具体产品（Concrete Product） 抽象产品的子类；工厂类创建的目标类 描述生产的具体产品 抽象工厂（Creator） 具体工厂的父类 描述具体工厂的公共接口 具体工厂（Concrete Creator） 抽象工厂的子类；被外界调用 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 四、 实例&amp;代码1. 基本情况 背景：小X有一个塑料加工厂（仅生产A类产品）；随着客户需求变化，需要生产B类产品。 冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本。 解决方案：小X决定置办塑料分厂B来生产B类产品；2. 使用步骤(1) 创建抽象工厂类，定义具体工厂的公共接口123abstract class Factory&#123; public abstract Product Manufacture();&#125; (2) 创建抽象产品类 ，定义具体产品的公共接口123abstract class Product&#123; public abstract void Show();&#125; (3) 创建具体产品类（继承抽象产品类）， 定义生产的具体产品12345678910111213//具体产品A类class ProductA extends Product&#123; public void Show() &#123; System.out.println(&quot;生产出了产品A&quot;); &#125;&#125;//具体产品B类class ProductB extends Product&#123; public void Show() &#123; System.out.println(&quot;生产出了产品B&quot;); &#125;&#125; (4) 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法12345678910111213//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; public Product Manufacture() &#123; return new ProductA(); &#125;&#125;//工厂B类 - 生产B类产品class FactoryB extends Factory&#123; public Product Manufacture() &#123; return new ProductB(); &#125;&#125; (5) 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例123456789101112//生产工作流程public class FactoryPattern &#123; public static void main(String[] args)&#123; //客户要产品A FactoryA mFactoryA = new FactoryA(); mFactoryA.Manufacture().Show(); //客户要产品B FactoryB mFactoryB = new FactoryB(); mFactoryB.Manufacture().Show(); &#125;&#125; (6)结果12生产出了产品A生产出了产品B 五、 优缺点1. 优点 屏蔽产品的具体实现，调用者只关心产品的接口。 更符合开放封闭原则 每个具体工厂只负责创建对应的产品，符合接口隔离原则 扩展性高。2. 缺点 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。六、 应用场景作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。]]></content>
      <categories>
        <category>tools</category>
        <category>OOAD</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式（Simple Factory）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Simple-Factory%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、 前言工厂模式主要是为创建对象提供过度接口，以便将创建对象的具体过程隔离屏蔽起来，达到提高灵活性的目的。 工厂模式可以分为三类：简单工厂模式（Simple Factory）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）。这三种模式从前到后逐步抽象，并且更具一般性。本文会简单概述开发中最常用的设计模式 - 简单工厂模式。 在阅读下文前强烈建议先阅读设计模式简介 二、含义简单工厂模式又称静态工厂方法模式（因为工厂类定义了一个静态方法）。在现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。 它存在的目的很简单：定义一个用于创建对象的接口。 三、解决的问题将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。即使用者可直接消费产品而不需要知道其生产的细节 四、 模式原理1. 模式组成 组成（角色） 关系 作用 抽象产品（Product） 具体产品的父类 描述产品的公共接口 具体产品（Concrete Product） 抽象产品的子类；工厂类创建的目标类 描述生产的具体产品 工厂（Creator） 被外界调用 根据传入不同参数从而创建不同具体产品类的实例 2. UML类图 3. 使用步骤 创建抽象产品类&amp;定义具体产品的公共接口。 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品。 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例。 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例。五、 实例&amp;代码1. 基本情况 背景：小X有一个塑料生产厂，用来做塑料加工生意。 目的：小X希望通过简单工厂模式实现3款产品的生产。2. 使用步骤(1) 创建抽象产品类，定义具体产品的公共接口123abstract class Product&#123; public abstract void Show();&#125; (2) 创建具体产品类（继承抽象产品类），定义生产的具体产品1234567891011121314151617181920//具体产品类Aclass ProductA extends Product&#123; public void Show() &#123; System.out.println("生产出了产品A"); &#125;&#125;//具体产品类Bclass ProductB extends Product&#123; public void Show() &#123; System.out.println("生产出了产品C"); &#125;&#125;//具体产品类Cclass ProductC extends Product&#123; public void Show() &#123; System.out.println("生产出了产品C"); &#125;&#125; (3) 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例1234567891011121314151617181920class Factory &#123; public static Product Manufacture(String ProductName)&#123;//工厂类里用switch语句控制生产哪种商品；//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。 switch (ProductName)&#123; case "A": return new ProductA(); case "B": return new ProductB(); case "C": return new ProductC(); default: return null; &#125; &#125;&#125; (4) 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例1234567891011121314151617181920212223242526272829303132333435//工厂产品生产流程public class SimpleFactoryPattern &#123; public static void main(String[] args)&#123; Factory mFactory = new Factory(); //客户要产品A try &#123; //调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例 mFactory.Manufacture("A").Show(); &#125;catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; //客户要产品B try &#123; mFactory.Manufacture("B").Show(); &#125;catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; //客户要产品C try &#123; mFactory.Manufacture("C").Show(); &#125;catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; //客户要产品D try &#123; mFactory.Manufacture("D").Show(); &#125;catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; &#125;&#125; (5) 输出结果1234生产出了产品A生产出了产品B生产出了产品C没有这一类产品 六、优缺点1. 优点 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦。 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则。 面向接口编程，而不是面向实现编程。2. 缺点 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响。 违背开放封闭原则，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。七、应用场景 当客户程序不需要知道要使用对象的创建过程。 客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。]]></content>
      <categories>
        <category>tools</category>
        <category>OOAD</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式简介]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[一、 定义及作用1. 定义设计模式（Design pattern）是软件开发人员在软件开发过程中面临特定问题设计的解决方案，这些解决方案是众多开发人员经过相当长一段时间的试验和错误总结出来的。 2. 作用 提高代码复用率，降低开发成本和周期 提高代码的可靠性 让代码更容易被他人理解二、 设计原则在设计模式中，强调如下六大原则：1. 开放封闭原则（Open Close Principle） 一个实体（类、函数、模块等）应该对扩展开放，对修改关闭 每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。 符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。 可以使程序的扩展性更好，易于维护和升级。 需要使用接口和抽象类。2. 里氏替换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石。 在软件开发过程中，子类替换父类后，程序的行为是一样的。 只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而子类也能够在基类的基础上增加新的行为。 LSP是对开放封闭原则的补充，是对实现开放封闭原则的具体步骤的规范。3. 依赖倒置原则（Dependence Inversion Principle） 针对接口编程，依赖于抽象而不依赖于具体。 细节应该依赖于抽象，而抽象不应该依赖于细节。 所谓的 面向接口编程，而不是面向实现编程 。这样可以降低客户与具体实现的耦合。4. 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好。 不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。 要降低类之间的耦合。 强调降低依赖，降低耦合。5. 迪米特法则（Demeter Principle） 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 又称：最少知道原则。 遵守迪米特法则的模块修改时影响的更少，扩展更加容易。 外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。6. 合成复用原则（Composite Reuse Principle） 尽量使用合成/聚合的方式，而不是使用继承。 三、 设计模式分类设计模式总共分为三大类，共23种设计模式。]]></content>
      <categories>
        <category>tools</category>
        <category>OOAD</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云搭建typecho博客平台]]></title>
    <url>%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAtypecho%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[经过半年多的折腾，我的博客最终在阿里云的服务器成功落户，中间经历了更换域名，导入ssl证书，更换博客平台，网站迁移，网站备案等一系列事件。在弄这些东西的时候，免不了查询资料，我发现国内的资料要么比较老，要么就不全。这篇博客是我安装的一个记录，也可以算是备份。如果有和我一样情况的，本文也可以是一个参考。 使用本文教程有几个前提要求： 租用的有服务器，系统为ubuntu16.04（其他系统大同小异） 购买的有域名且通过工信部icp备案。（未备案的服务器需在中国大陆境外） 本文分为以下几个部分：lnmp环境安装、网站部署、部署typecho、备份及迁移后的恢复 一、lnmp环境安装lnmp在网上有很多安装方法，需要输入大量的命令，这里取最简单的lnmp一键安装包 1. 登录服务器使用xshell或类似的SSH工具登录服务器，登录后运行：1screen -S lnmp 如果提示1screen:commend not found 可以先安装screen后再执行。使用screen的目的在于防止安装中途ssh由于长时间未通信而断开链接，导致安装程序中断。如果实在不想弄可以跳过。 2. 下载并安装lnmp一键安装包1wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp 安装过程在官方说明中已经很详细指出：官方安装说明最简单的教程就是除了提示输入MySql密码时，其他一路回车选默认值就好。 二、 网站部署1. 添加网站1lnmp vhost add 步骤同样可以在官方说明中找到：添加网站说明需要注意的是 网站的目录最好设置为/home/wwwroot/default这样方便我们以后添加数据库管理界面。 提示是否启动伪静态Allow Rewrite rule? (y/n)时，输入y，并在选择配置文件时，输入typecho。 其他的看个人需求添加，懒得看的全部回车就好。2. 域名解析去域名注册商把网站解析到服务器ip上。此过程不再赘述。3. 添加ssl证书在这里我使用的是阿里云Symantec免费SSL证书，申请方法自行百度。将适用于Nginx的证书文件下载下来。在/usr/local/nginx目录下新建cert目录，并将下载的两个文件放到cert目录下，并分别命名为ssl.pem; ssl.key。之后将nginx中对应域名的conf文件（一般位于”/usr/local/nginx/conf/vhost”中）先备份，之后将80端口部分修改为：123456789101112server &#123; listen 80; #listen [::]:80;\ server_name your_server_name; index index.html index.htm index.php default.html default.htm default.php; root /home/wwwroot/default; include typecho.conf; include enable-php-pathinfo.conf; ##强制把http请求跳转到https请求 return 301 https://$server_name$request_uri;&#125; 添加443端口部分:123456789101112131415161718192021222324252627282930313233343536server&#123; listen 443; server_name your_server_name; ssl on; root html; index index.html index.htm index.php; ssl_certificate /usr/local/nginx/cert/ssl.pem; ssl_certificate_key /usr/local/nginx/cert/ssl.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; include typecho.conf; include enable-php-pathinfo.conf; location /nginx_status &#123; stub_status on; access_log off; &#125; location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; location ~ .*\.(js|css)?$ &#123; expires 12h; &#125; location ~ /\. &#123; deny all; &#125; access_log /home/wwwlogs/access.log; &#125; 完成后重启nginx服务nginx -s reload 注意：在此conf文件中，我默认开启了http强制跳转https，并解决了typecho在lnmp一键安装包中由于伪静态导致的后台无法访问的问题。有其他需要可以自行改动。 三、 部署typecho1. 上传typecho到网站目录先从官网下载安装包，再上传到/home/wwwroot文件夹下。使用tar zxvf解压缩后，将老default文件夹改为old，将解压出的build文件夹命名为default。给新default文件夹操作权限1chmod 777 default 2. 添加数据库由于上一步替换掉了之前的default文件夹，因此phpmyadmin这个在线数据库管理系统需要从新安装。进入~/lnmp1.4目录，执行 ./upgrade.sh phpmyadmin输入4.6.6即可。之后访问服务器ip/phpmyadmin用root登录后新建typecho数据库。 3. 安装typecho直接访问网站即可跳到typecho的安装界面，按步骤安装完成后即可使用。如果提示无法创建文件xxx，请手动创建xxx，是因为在1中未给文件夹操作权限。 四、 备份及迁移后的恢复1. 备份在博客的日常使用中，建议至少每一个月备份一次。由于typecho自带的备份不能备份主题，图片和插件，因此如果使用了第三方主题、上传了插件或在博客中上传了图片，都需要将default/usr下的plugins、themes、uploads三个文件夹进行备份，下载。12#压缩命令tar zcvf beifen.tar.gz /home/wwwroot/default/usr 之后可以把压缩包保存到本地。 2. 恢复在进行服务器迁移时，安装完typecho后，可以先恢复typecho自带的备份，恢复完成后会发现文章中的图片全都打不开，之后就可以将备份好的usr上传到服务器，解压后移动到相应的位置即可。 五、 注意事项 typecho部署在阿里云上的话，上传图片会被防火墙拦截，需要在控制台防火墙中将ftp的21端口打开。 有更新今后会补充。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步和异步，阻塞和非阻塞]]></title>
    <url>%2F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[在学习计算机操作系统的时候，经常会听老师讲到同步(Sync)/异步(Async)、阻塞(Block)/非阻塞(Unblock)四种调用方式，并且这些概念经常会搞混，下面说说我个人的理解过程。 1. 同步和异步 同步：所谓同步，就是在发出一个功能调用之后，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大部分函数都是同步调用。 异步：就是在发出一个功能调用之后，调用返回。被调用的部件在完成后，通过状态、通知或回调来通知调用者。 在程序里，同步和异步，是从程序通信过程来定义的。同步过程发起请求后，等到结果再返回；异步过程发起请求后立即返回，后续有事件通知。即调用的结果是调用者主动去获取的（比如一直等待recvfrom或者设置超时等待的select），则为同步。而调用结果是被调用者在完成后通知调用者的（比如Windows的IOCP），则为异步。 2. 阻塞和非阻塞 阻塞：阻塞调用是指调用结果返回之前，当前进程被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，当I/O操作结束，该线程阻塞状态解除，重新变为活动线程）。函数只有在得到结果之后才会返回。 非阻塞：和阻塞的概念相对，指在不能立即得到结果之前，该函数不会阻塞当前的线程，而会立刻返回，线程处于活跃状态。 在程序里，阻塞和非阻塞，是针对调用者所在线程是否在调用后主动挂起来说的。即如果在线程中调用者发出调用后，在被调用者返回之前，该线程主动挂起，则为阻塞。若线程不主动挂起，而继续向下执行，则为非阻塞。 3. 四者的联系和区别我之前经常把同步和阻塞搞混，认为是等同的。其实根本不一样，对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 在这里我将列举一个找资料过程中看到的例子来说明同步和异步、阻塞和非阻塞之间的联系和区别。 老张用两个水壶烧水（普通水壶和响水壶）。 同步阻塞：老张把普通水壶放到火上，站着等待，每隔一段时间看看水开没开。 同步非阻塞：老张把普通水壶放到火上，然后去做别的事，同样每隔一段时间看看水开没开。 异步阻塞：老张把响水壶放到火上，站着等待，水烧开时水壶呜呜响，从而知道水开了。 异步非阻塞：老张把响水壶放到火上，然后去做别的事，水烧开时水壶呜呜响，从而知道水开了。 所谓同步异步，只是对于水壶而言。 普通水壶：同步； 响水壶：异步。 所谓阻塞非阻塞，只是针对老张而言。 站着等待的老张：阻塞； 做别的事的老张：非阻塞。 情况1、3中的老张就是阻塞的，在等待的时候，别人喊他是不会应答的。虽然3中响水壶是异步的，但对于阻塞的老张没有太大意义。 所以一般异步是配合非阻塞来使用的，这样才能发挥异步的作用。]]></content>
      <categories>
        <category>tools</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活中的算法]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前几天梦见幼儿园排队，想到了冒泡排序，抖个机灵发朋友圈里了，还说要总结生活里的算法……这几天一直在想，先把目前能想到的写出来吧，以后再补充。（以后再也不乱立flag了） 程序员穿袜子 这是一个程序员圈子里很经典的一个梗。从名字中就散发出生活的清香。 程序员把他所有的袜子都放在卧室的地板上，摆成一个实心三角形（小顶堆）。每天下班回家就把袜子放在最后面，也就是堆的末尾。然后每次拿起两双袜子放在鼻子下闻闻，把相对较臭的放在后面，不断向前调整袜子在三角形中的位置，直到下面的都比上面的臭为止。这样，程序员每天出门就能方便的选出一双最不臭的袜子。 在这个梗里，程序员使用的是堆排序，这是一个有味道的算法…… 二分找肉法 吃串串香的时候，串特别长，一段串着肉，但有的店家没弄好，煮一会儿后肉全掉汤里了。 假设我手中有32根串，但末端只有一片牛肚。如果我一根一根找，那么在最坏的情况下，我需要O（n），也就是32次挑选才能选出那根有肉的串。 于是我发明了二分找肉法，首先把手里的串分成等量的两份，然后再对有肉的一份进行同样的操作，直到n=1为止。 复杂度从O（n）降为O（logn），只需要5次挑选。 在我发明算法并找到牛肚的时间里，汤里的31串牛肚估计已经老了。 衣柜算法 在家里的时候，衣服分门别类放成几摞，大的衣服还能挂起来，找衣服是很轻松的，近似于O（1）的复杂度，可以看作实现了哈希字典。 在寝室里衣柜基本只够将所有的衣服叠在一起放几摞（这里为了说明方便，按1摞处理）。要找一件不起眼的衣服，需要遍历一整叠，找到后还需要先把上层的衣服pop出来，取衣服过后再push进去……差不多就是一个stack栈，非常不适合查找的一种数据结构（手动再见） 课堂算法 高中上课，语数外理化生每节课40分钟，一般不会连上，体育音乐之类一周一节，还时常被抢占，处于饥饿状态，这里使用的是多级反馈时间片轮转调度算法。 上大学后，一节课50分钟，还是两节连着上，时间片边长了，也没了抢占，这就是基本的时间片轮转调度算法。 寒暑假在家，想学习劳逸结合，也运用时间片轮转调度算法。睡觉一片，吃饭一片，看视频一片，吃鸡一片，吃鸡一片，吃鸡一片，然后没时间学习了…… 想想真是佩服自己高中时候，上节课刚考完数学休息几分钟马上就能写一篇作文，几门课切换自如，寄存器如此强大，现在它已经快废了吧╮(╯▽╰)╭ 课文索引 以前语文课老师要求我们一人读一段课文，快到我的时候，我快速浏览全文，建立起跳转索引，然后仔细听前面同学读的内容，迅速匹配到相应的字符串。 查字典 小学查字典时会用trie树（在索引上找），初中以后就直接哈希（翻首字母）+ 二分（胡翻）了。 杂七杂八的一些小算法（合起来写） 幼儿园老师按高低个排队，“高的站后面，小的站前面”、“你们俩换一下”，这是对基本有序数组的冒泡排序。 忘记密码锁密码的时候，一个一个试，穷举。这局打完我再去上课，贪心算法。各种心里推断题，1、你开心吗？A、开心，去第2题。B、不开心，去第3题。有向图。]]></content>
      <categories>
        <category>tools</category>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诸事皆宜，百无禁忌]]></title>
    <url>%2F%E8%AF%B8%E4%BA%8B%E7%9A%86%E5%AE%9C%EF%BC%8C%E7%99%BE%E6%97%A0%E7%A6%81%E5%BF%8C%2F</url>
    <content type="text"><![CDATA[以前觉得这个世界是讲道理的，其实不是。 勤勤恳恳做一些我认为对的事情，为了某个目标倾尽所有，我相信只要自己足够真诚，就一定可以得到这个世界的认可。 可这个世界残酷就残酷在存在太多太多的事与愿违。 我所有的只能让自己安心，除此之外并不一定就能够被承认。比如认真念书，到头来也没能有什么好成绩; 我拿出来全部的真诚，也没能处理好人与人之间的关系。我以为自己努力不犯错，就不会不被爱，不会被曲解，不会被拋弃。 其实不是的。世界是冷漠的，它不在乎你付出多少，也不讲人情，不存在因果报应，也没什么合理不合理的。 我所得到的都是侥幸，所失去的才是人生。 这样的心态真的是很棒啊。 我当然相信这个世界上有真正热爱生活的人，但一定也会有不少人，能够心平气和地面对得失，放弃该放弃的，控制能控制的，在深不见底的绝望里冷漠走过，生出更高级的热爱。 于是结果啊过程啊都没那么重要了，关键还是看自己的态度。尽人事听天命大概就是这么一个道理。 已经无所谓这个世界讲不讲道理了，无愧于心，就是我现在最大的追求。]]></content>
      <categories>
        <category>方方说</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《2018刑侦科推理试题》详解]]></title>
    <url>%2F%E3%80%8A2018%E5%88%91%E4%BE%A6%E7%A7%91%E6%8E%A8%E7%90%86%E8%AF%95%E9%A2%98%E3%80%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近江苏网警的一篇《2018刑侦科推理试题》养活了很多自媒体朋友，我最初了解的渠道是在qq看点……据报道，有网友晒出解题过程要满满好几页稿纸，有人用电脑软件计算竟然花了近半小时……我按自己的思路走一遍发现还不算太难，是不是媒体故意夸大其词来博眼球？老一辈教导我们：“不要听风就是雨，将来报道出了偏差，是要负责任的。”本着马列唯物主义的质疑精神，我写出了自己的解题过程，只有6行；电脑模拟基本秒出答案，为了增强真实性，本文附带模拟源代码。 首先亮题： 再亮答案： 思路（非代码相关人士可以跳两段再看） 说实话，看到这题的时候我是懵逼的，但只要读懂题意，完全不需要动脑子推理，不需要切入点，编好程序瞎鸡儿运行就好。 我记得有人曾跟我说过，你们敲代码的是不是计算能力都特好，其实说实话，如果有手机，2位数+2位数我都懒得算，能用机器准确得出结果，为什么要费脑子。 回归本题，用C++编程，暴力列举出所有的情况，再一一验证条件，运行。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; int answer[10]; int b[10]; int count[4]; int i; int j; int k=0; int max, min; max=0; int max_order = 0; min=10; int min_order = 0; char test='A'; for(i=0;i&lt;10; i++)&#123; answer[i] = 0; b[i]=0; count[i]=0; &#125; printf("test\n"); for(b[0]=0; b[0]&lt;4; b[0]++)&#123; for(b[1]=0; b[1]&lt;4; b[1]++)&#123; for(b[2]=0; b[2]&lt;4; b[2]++)&#123; for(b[3]=0; b[3]&lt;4; b[3]++)&#123; for(b[4]=0; b[4]&lt;4; b[4]++)&#123; for(b[5]=0; b[5]&lt;4; b[5]++)&#123; for(b[6]=0; b[6]&lt;4; b[6]++)&#123; for(b[7]=0; b[7]&lt;4; b[7]++)&#123; for(b[8]=0; b[8]&lt;4; b[8]++)&#123; for(b[9]=0; b[9]&lt;4; b[9]++)&#123; if(b[1]&lt;2)&#123; if(b[4]!=(b[1]+2)) continue;&#125; else &#123;if(b[4]!=(b[1]-2)) continue;&#125; if(b[2]==0)&#123; if((b[5]!=b[1]) || (b[1]!=b[3]) ||(b[5]!=b[3])|| (b[2]==b[5]) || (b[2]==b[1] ) || (b[2]==b[3]) ) continue; &#125;else if(b[2]==1)&#123; if((b[2]!=b[1]) || (b[1]!=b[3]) ||(b[2]!=b[3])|| (b[2]==b[5]) || (b[5]==b[1] ) || (b[5]==b[3]) ) continue; &#125; else if(b[2]==2) &#123; if((b[5]!=b[2]) || (b[5]!=b[3]) ||(b[2]!=b[3])|| (b[2]==b[1]) || (b[5]==b[1] ) || (b[1]==b[3]) ) continue; &#125; else&#123; if((b[5]!=b[1]) || (b[1]!=b[2]) ||(b[5]!=b[2])|| (b[3]==b[5]) || (b[3]==b[1] ) || (b[2]==b[3]) ) continue; &#125; if(b[3]==0)&#123; if(b[0] != b[4] ) continue; &#125; else if (b[3]==1)&#123; if(b[1] != b[6] ) continue; &#125; else if (b[3]==2) &#123; if(b[0] != b[8] ) continue; &#125; else &#123; if(b[5] != b[9] ) continue; &#125; if(b[4]==0)&#123; if(b[7] != b[4] ) continue; &#125; else if (b[4]==1)&#123; if(b[4] != b[3] ) continue; &#125; else if (b[4]==2) &#123; if(b[4] != b[8] ) continue; &#125; else &#123; if(b[4] != b[6] ) continue; &#125; if(b[5]==0)&#123; if((b[7] != b[1]) || (b[7]!=b[3] ) ) continue; &#125; else if (b[5]==1)&#123; if((b[7] != b[0]) || (b[7]!=b[5] ) ) continue; &#125; else if (b[5]==2) &#123; if((b[7] != b[2]) || (b[7]!=b[9] ) ) continue; &#125; else &#123; if((b[7] != b[4]) || (b[7]!=b[8] ) ) continue; &#125; for(j=0; j&lt;4; j++)&#123; count[j]=0; &#125; for(j=0; j&lt;10; j++)&#123; count[b[j]]++; &#125; max = 0; for(j=0;j&lt;4;j++)&#123; if (count[j] &gt; max) &#123;max = count[j]; max_order = j;&#125; &#125; min = 10; for(j=0;j&lt;4;j++)&#123; if (count[j] &lt; min) &#123;min = count[j]; min_order = j;&#125; &#125; if(b[6]==0)&#123; if(( min_order != 2)) continue; &#125; else if (b[6]==1)&#123; if(( min_order != 1)) continue; &#125; else if (b[6]==2) &#123; if(( min_order != 0)) continue; &#125; else &#123; if(( min_order != 3)) continue; &#125; if(b[7]==0)&#123; if(abs((b[6]-b[0]))==1) continue; &#125; else if (b[7]==1)&#123; if(abs((b[4]-b[0]))==1) continue; &#125; else if (b[7]==2) &#123; if(abs((b[1]-b[0]))==1) continue; &#125; else &#123; if(abs((b[9]-b[0]))==1) continue; &#125; if(b[8]==0)&#123; if((b[0]==b[5]) == (b[4]==b[5]) ) continue; &#125; else if (b[8]==1)&#123; if((b[0]==b[5]) == (b[4]==b[9]) ) continue; &#125; else if (b[8]==2) &#123; if((b[0]==b[5]) == (b[4]==b[1]) ) continue; &#125; else &#123; if((b[0]==b[5]) == (b[4]==b[8]) ) continue; &#125; if(b[9]==0)&#123; if((max-min)!=3 ) continue; &#125; else if (b[9]==1)&#123; if((max-min)!=2 ) continue; &#125; else if (b[9]==2) &#123; if((max-min)!=4 ) continue; &#125; else &#123; if((max-min)!=1 ) continue; &#125; //printf("%d, %d, %d , %d ,max %c : %d ; min %c : %d\n", count[0], count[1], count[2], count[3],max_order+test, max, min_order+test, min ); printf("final answer is :\n"); for(j=0;j&lt;10;j++)&#123; printf("%c ", (char)(b[j]+test)); &#125; printf("\n"); for(j=0; j&lt;4; j++)&#123; count[j]=0; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 正常解题思路 本解法不需要高深的数学基础，不需要编程知识，只要能读懂题意，抓对方法，解题其实很快。整个题干虽然都很虚，但巧妙利用阅读理解，可以推出很多信息。 条件1：从第三题可以得出，2、3、4、6题里面，有3题的答案是相同的。条件2：从第10题可以得出，本试卷答案最多的字母，数字也不会超过5，且本试卷答案最少的字母，肯定小于2（为1或者0）（要想明白这个道理需要一定的逻辑能力） 这种逻辑题，一旦知道了3题的答案，极大概率就能推出其他答案。鉴于单选题的性质，挨个尝试就可以了。 1、若3选A，则2、4、6选项相同且不为A，条件1、2满足。1.1、若2、4、6选B，进而推出5、7为D，不满足条件2，错。1.2、若2、4、6选C，由2知5为A，由6知3、8、10为A，条件1、2满足。1.2.1、由8知2、5、10与1答案字母相邻，2为C，5为A，10为A，所以1为B，条件1、2满足。1.2.1.1、理到现在，只有7、9未知，由已知答案可得9为B，条件1、2满足。1.2.1.1.1、最后，7选D，条件1、2满足。 所以最终答案为： 总结： 不要相信无良媒体满嘴跑火车，天文科普就是被这群智障媒体弄得一直没起色。 要培养良好的阅读和推理能力。 要认识到这不是分散的10道选择题，而是1道整体的推理题。 一张纸，一只笔，解答事半功倍。 程序还有优化空间，比如可以把简单的if判断放前面，快速排查掉一些无用的条件。 所以，@江苏网警，贵单位的刑侦科报道处怎么走？]]></content>
      <categories>
        <category>tools</category>
        <category>code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《新东方快车谋杀案》一部画面比剧情好看的推理电影]]></title>
    <url>%2F%E3%80%8A%E6%96%B0%E4%B8%9C%E6%96%B9%E5%BF%AB%E8%BD%A6%E8%B0%8B%E6%9D%80%E6%A1%88%E3%80%8B%E4%B8%80%E9%83%A8%E7%94%BB%E9%9D%A2%E6%AF%94%E5%89%A7%E6%83%85%E5%A5%BD%E7%9C%8B%E7%9A%84%E6%8E%A8%E7%90%86%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[在去年的朋友圈中，我才知道了这个广为人知的故事，这个曾经有过一版堪称经典的电影。直到今天，我才想起来欣赏。说实话，我之前并没有刻意搜索过这个故事，所以我会以一个新人的角度来欣赏这部作品。 在电影的开场，波洛吃早餐量鸡蛋，接着双脚踩屎，再后面用拐杖放倒逃犯，这一切都是在塑造波洛严苛到极致的形象，这种巧妙的安排让我们初识的观众可以很轻松的认识波洛。 当本剧唯一大反派卡塞蒂变成盒子的时候，我才发现他是上了火车的杰克船长。在他被捅死之后，我还下意识觉得他会手上夹着一枚金币，突然跳起来说：“女士们先生们，你们将永远记住这一天，因为你们差点就捅死了杰克.斯派洛船长。” 在中间的问询阶段，电影显得略显沉闷。尽管导演采用平行剪辑的手法加快节奏，刻意去增加的剧情的刺激性，但还是处理偏颇。直到最后的揭秘，电影让所有人走出车厢，在隧道入口排一张长桌，十二名乘客齐聚，呈现《最后的晚餐》之态。晶莹白雪和幽邃黑洞之间，昏黄的灯火下，12名装作不认识的凶手。画面十分美好，可是在剧情上不是特别理想，感觉有点像为了实现《最后的晚餐》的镜头，又受制于车厢空间太小，而做出的无奈之举。 最后波洛在说出了12人联合复仇的真相之后，掏出枪放在桌上说：“你们现在唯一的选择是杀了我，把我扔在冰湖里，因为我不会说谎。”然后女话剧演员不愿为了掩盖罪行而杀一个无辜的人，拿起枪自杀，发现枪里没子弹……这点我在思考很久后才明白，这是波洛给他们的一个测试。虽然他们杀的是一个十恶不赦的罪犯，但在侦探眼中，他们都参与了杀人，也应该为自己的行为承担责任，不然法律的威严何在？而女话剧演员自杀，让波洛知道，他们在自己生命受到威胁时，仍然不愿意为了掩盖罪行而杀掉一个无辜的人。这个举动才是波洛违背自己原则放过所有人的原因。 脑洞 最后波洛准备走出车厢时，电影的旁白说：“阿姆斯特朗少校，我终于可以给你回信了……“我忽然觉得波洛才是本案真正的幕后推手，为了确保谋杀可以顺利执行，波洛放下偏执和一个花花公子为友，才搭乘上这班列车。他亲临现场，每一个步骤后都开门检查走廊，用自己的推理，演出了戏中戏，为整个案情上了双保险，即使其他人搞砸了，有他最著名侦探的头衔在，最后也可以顺利圆回来。]]></content>
      <categories>
        <category>方方说</category>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《月亮和六便士》----是否有个魔鬼抓住了他的灵魂？]]></title>
    <url>%2F%E3%80%8A%E6%9C%88%E4%BA%AE%E5%92%8C%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B-%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%AA%E9%AD%94%E9%AC%BC%E6%8A%93%E4%BD%8F%E4%BA%86%E4%BB%96%E7%9A%84%E7%81%B5%E9%AD%82%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[啃完了《月亮与六便士》，有种当头一棒的痛感。总是渴望找到一项东西，然后为之不管不顾、 为之疯狂。一潭死水的生活最是让人窒息 。最痛苦的事不是平衡地上的六便士和天上月亮的关系，而是当你想仰望，却压根没找到天上的月亮。 摘录： 说这些豪言壮语的人可能还觉得他们在说一些前人未曾道过的真理，但是实际上连他们说话的腔调前人也已经用过一百次，而且丝毫也没有变化。钟摆摆过来又荡过去，这一旅程永远反复循环。 在那个时代谈话仍然被看作是一种需要下功夫陶冶的艺术，一句巧妙的对答比锅子底下噼啪爆响的荆棘更受人赏识，格言警句当时还不是痴笨的人利用来冒充聪敏的工具， 同情体贴本是一种很难得的本领，但是却常常被那些知道自己有这种本领的人滥用了。他们一看到自己的朋友有什么不幸就恶狠狠地扑到人们身上，把自己的全部才能施展出来，这就未免太可怕了它使人想到一条平静的小河，蜿蜒流过绿茸茸的牧场，与郁郁的树荫交相掩映，直到最后泻入烟波浩渺的大海中。但是大海却总是那么平静，总是沉默无言、声色不动，你会突然感到一种莫名的不安。 有些人的生活只是社会有机体的一部分，他们只能生活在这个有机体内，也只能依靠它而生活，这种人总是给人以虚幻的感觉； 我决定第二天晚上再去找思特里克兰德，因为我本能地觉得，必须细致盘算，并选定这一时间去。如果想从感情上说动一个人，在午饭以前是很少会成功的。 只有诗人同圣徒才能坚信，在沥青路面上辛勤浇水会培植出百合花来。 有人说灾难不幸可以使人性高贵，这句话并不对；叫人做出高尚行动的有时候反而是幸福得意，灾难不幸在大多数情况下只能使人们变得心胸狭小、报复心更强。 他非常重感情，但是在他那很容易就被打动的感情里面却含有某种愚蠢的东西，让你接受了他好心肠的帮助却丝毫没有感激之情。向他借钱就好象从小孩儿手里抢东西一样；因为他太好欺侮，你反而有点儿看不起他。 有时候一个人的外貌同他的灵魂这么不相称，这实在是一件苦不堪言的事。 如果灵魂真能出窍的话，不论出什么代价我也得试一次；只有这样我才能在画室里看到他俩私下如何过活，才能听到他们交谈些什么。总之一句话，我没有可以供我的幻想力发挥作用的最小依据。 女人们不断为了爱情而自寻短见，但是一般说来她们总是做得很小心，不让自杀成为事实。通常这只是为了引起她们情人的怜悯或者恐怖而作的一个姿态。 护士用她那双宁静、慈祥的眼睛望着戴尔克，这双眼睛曾经看到过人世的一切恐怖和痛苦，但是因为那里面装的是一个没有罪恶的世界的幻景，所以她的目光是清澈的。 我们非常可怜地想把自己心中的财富传送给别人，但是他们却没有接受这些财富的能力。因此我们只能孤独地行走，尽管身体互相依傍却并不在一起，既不了解别的人也不能为别人所了解。 他的思想这时会平静地飘浮在九天之上，他对那个女人感到又嫌恶又可怕，也许那感觉就象一只翩翩飞舞于花丛中的蝴蝶，见到它胜利地蜕身出来的肮脏的蛹壳一样。 小丑的嘴唇在微笑，他的笑话越来越滑稽，因为在他逗人发笑的时候他更加感到自己无法忍受的孤独。 上帝的磨盘转动很慢，但是却磨得很细。 感想：月亮代表高高在上的理想，而六便士代表平凡的现实。理想可能是遥不可及的悬在空中的月亮，而世俗的名誉财富却像六便士一样只要老老实实遵守社会规范努力工作，都是唾手可得的。主人公为了追求画画的理想而放弃了现实的世俗生活，虽然穷困潦倒几次濒临死亡，仍然不忘初心，最终虽然少有人见证到，但还是创造出了传世之作。主人公本来是一个老实体面的经济工作者，有着稳定充足的收入，有幸福的家庭；但突然有一天，他决定放弃这种生活，去追寻自己的艺术。这种转折是毫无征兆的，他就像豁然开朗一般，无所顾忌地抛弃世俗的一切，去追寻自己的艺术理想。 “我怀疑他的灵魂里是否深埋着某种创作本能，那种本能虽然受他的生活环境所抑制，却像肿瘤在活体器官中膨胀那样顽强地生长着，最终控制了他整个人，迫使他不由自主地采取行动。” 前段时间一直在想，我们是不是真的能够看清自己内心所想所盼。我们所成为的人，到底是灵魂的决定还是外界的推动。生活在人群当中，不得不重视别人的看法和评价，不得不在心中住进一个卫兵，当有其他与普世价值相违背的想法冒出，卫兵本能的将其砍掉。可惜，抽刀断水，也许我不明白有什么不对，但始终觉得意难平。我忽然想到了顺治，万里河山，说走就走。 连最至高无上的权利，都阻挡不了内心的渴望。 尼采为什么会疯 梵高为什么割掉耳朵 海明威为什么自杀 追逐梦想就是追逐自己的厄运，在满地都是六便士的街上，他抬起头看到了月光。可能他想通了这一切，才能踩在六便士上，赏着月光，衣衫褴褛，食不果腹。 是否有个魔鬼抓住了他的灵魂？让他只能俯首称臣。 那些命中注定的狂热，对抗卫兵的勇气，最终让他内心安宁。 所有的热爱，在投身于其中的时候，已经得到了最大的报酬，而是否有所认可与收获，都应当处之泰然。 主人公为什么最后选择烧掉他那画有惊世之作的屋子，因为最丰腴的愉悦感，已经在创作的时候产生，任他人看与不看，都与我何干？]]></content>
      <categories>
        <category>方方说</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Typecho!]]></title>
    <url>%2FHello-Typecho%2F</url>
    <content type="text"><![CDATA[这是由Typecho创建的文章！当然这是一篇初始页，也代表着我的博客迎来了一次翻天覆地的改变，虽然以前的博客已经 迁移到xiaofangdyd.tech上 关闭，就让那些过去的就过去吧！更新记录： 博客迁移至洛杉矶、北京Github服务器。（2019.01.29） 使用七牛oss托管图床（2019.01.29） 域名备案 博客程序从Wordpress更换为Typecho轻量级博客框架。 博客采用hexo框架 尽量用Markdown格式将之前的文章转移过来。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>typecho</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《雪国列车》--很多精彩，很多遗憾]]></title>
    <url>%2F%E3%80%8A%E9%9B%AA%E5%9B%BD%E5%88%97%E8%BD%A6%E3%80%8B-%E5%BE%88%E5%A4%9A%E7%B2%BE%E5%BD%A9%EF%BC%8C%E5%BE%88%E5%A4%9A%E9%81%97%E6%86%BE%2F</url>
    <content type="text"><![CDATA[《雪国列车》是我非常喜欢的一部电影，将人类文明史浓缩在一节节车厢里面，凭依上帝视角进行审视。 列车 尾部车厢，象征着阶级社会最底层的劳动者，最为凄惨。 蛋白质块生产车厢，象征着给底层社会提供生活最低保障品的最下服务阶层。 维护列车秩序的军队，象征着国家的暴力机器，他们在最底层的边缘。 植物区，水族馆等，象征着技术劳动者的中间阶层，相对于底层而言待遇稍好，但对社会变革无所适从，他们既服从于统治阶层的权威，又对底层劳动者怀有同情与恐惧。 高级乘客车厢，象征着腐朽的统治阶级，越往车头走，堕落的越彻底。 引擎车厢，象征着阶级社会的最高统治者，一直控制着人类社会方向的最少数人。 “车就是世界，我们就是全人类。” 电影中，人们藏起武器，害怕给小孩不良的印象；而和蔼可亲的怀孕女老师，却当着学生的面悍然拔枪杀人，分发新年礼物貌似慈善的仆人，其实是大屠杀的执行者，隐喻的意思不言自明。 电影中，儿童象征着人类的未来。有三种儿童，一种是底层劳动者中倔强生存的儿童；一种是权贵阶层被深度洗脑的儿童；第三种是最终被当成列车零件，机械化地维护阶级社会秩序的儿童。这也正象征着人类的三种未来。 火在电影中有许多次应用。一次是照亮黑暗的火炬，一次是点燃炸药的火种。《无人区》的一句话特别适合用在这里“我认为人类和动物的区别不是放弃自私，而是人类会使用火” 虽然整部电影的剧情匪夷所思，但最终火车还是被炸掉了，大家一起翘辫子了。自由和平等的代价是巨大的，不自由毋宁死，要死也要一起死。 整个影片结束了，据说这个片子赞颂了革命精神，弘扬了马列主义价值观，可我看到的却是一群阶级底层人民的不满，不满是由于物质的分配不均，分配不均是因为阶级产生，阶级产生是由于人的控制欲和占有欲，因为人有欲望，每个人都会对自身所拥有的不满。 叔本华曾经说过，人得到了就空虚，人得不到就痛苦，人一生就生活在空虚和痛苦之中。尽管物质的丰富只能带来暂时的快乐，这道理人人都懂，但却总忍不住想要得到更多，因为这种欲望是与生俱来的，不去占有更多物质的人早就在远古时期就已经灭绝了，所有生存至今的人类，基因代码里就写下了一句话：“我要得到更多”。 说到底，一句话“因乘客对列车食品不满，酿成火车出轨特大事故”。]]></content>
      <categories>
        <category>方方说</category>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的100 = 100，但1000≠1000？]]></title>
    <url>%2FJava%E4%B8%AD%E7%9A%84100-100%EF%BC%8C%E4%BD%861000%E2%89%A01000%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如果我们在Java中运行一段代码：1234Integer a = 100, b = 100;System.out.println(a == b);Integer c = 1000, d = 1000;System.out.println(c == d); 你会得到：truefalse首先，先说明，Java是面向对象的编程语言，一切都是对象，但是为了编程的方便还是引入了基本数据类型，为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换，对应如下： 原始类型 boolean char byte short int long float double 包装类型 Boolean Character Byte Short Integer Long Float Double 所以最根本的一点区别就是：int的初始值是0，integer的初始值是null；其他还有一些显著的区别就是： Integer变量必须实例化后才能使用，而int变量不需要。 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。 下面再看几个例子来说明两者的区别：12345int i1 = 128;Integer i2 = new Integer(128);Integer i3 = 128;System.out.println(i1 == i2);System.out.println(i1 == i3); 结果均为true，因为包装类Integer在和int进行比较时，无论Integer变量是否为new生成，Integer会自动拆箱成int类型，变成两个int类型比较，所以只要两者数值相等，结果都为true。123Integer i3 = new Integer(100);Integer i4 = new Integer(100);System.out.println(i3 == i4); 结果为false，我们知道，如果两个引用指向同一个对象，用 = =表示他们是相等的；如果两个引用指向不同的对象，即使他们内容相同，但用= =表示他们是不相等的。由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。123Integer i5 = new Integer(100);Integer i6 = 100;System.out.println(i5 == i6); 结果为false，因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。 对于非new生成的Integer变量，编译时会调用valueOf()函数,例如：Integer i = 100;编译时就会被翻译成：Integer i = Integer.valueOf(100) 而Java API中对Integer类型的valueOf定义如下：1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。 最后再回到开始的那个代码中，a,b的值为100，在-128到127之间，因此它们指向了同一个对象，结果就为true；c,d的值在-128到127的范围之外，编译时依然调用的是new Integer()，但存放在常量池（方法区）中，因此结果就为false。 至于为什么需要缓存，理由就是，在此范围内的“小”整数使用率比范围外的“大”整数要高，因此，使用相同的底层对象是有价值的，可以减少潜在的内存占用。 总结： 无论如何，Integer与new Integer不会相等。不会经历拆箱过程，new出来的对象存放在堆，而非new的Integer常量则在常量池（在方法区），他们的内存地址不一样，所以为false。 两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。因为java在编译Integer i2 = 128的时候,被翻译成：Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存。 两个都是new出来的,都为false。因为内存地址不一样。 int和Integer(无论new否)比，只要数值相同，结果都为true，因为会把Integer自动拆箱为int再去比。 参考资料：Java基础之int和Integer有什么区别]]></content>
      <categories>
        <category>tools</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅过生活]]></title>
    <url>%2F%E4%BC%98%E9%9B%85%E8%BF%87%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[对我而言，我所向往的大学生活就是： 该上课就去上课，想逃课也可以逃课；该吃饭就去吃饭，想打球就去打球；该学习就学习，该聊天就聊天；爱睡懒觉就睡懒觉，决定早起就早起。 面对每一件事，在某种法律规则之内，不管喜不喜欢，强不强迫，专心的投入的出色的做。而不是上课的时候听不进去，想逃课又怕老师点名，只能趴在桌子上玩游戏；逃课的时候担心老师点名，陪着笑脸发讯息给朋友“老师点名了帮我签到啊，谢谢。”该吃饭的时候，放不下手中正忙的事，等忙完之后，匆匆跑去食堂只有剩饭剩菜；想吃零食吃辣条又担心长痘和地沟油，吃完以后喝一缸水排毒；想谈恋爱又开不了口，等着对方先说，结果刷微博发现对方发了一条和别人在一起的消息，只能握着屏幕咬碎钢牙点一个赞；学习的时候想着刷朋友圈刷微博，想着晚上玩什么游戏怎么玩，一下午看几页书，还是绪论；聊天和社团活动的时候心里想的是这话唠净浪费我时间，给我两个小时我都能复习完半本书了。 很多事情做不好的根源，在于“分心”二字，所谓分心，就是 时时刻刻，希望以最短的时间，博取最多的存在感，优越感和自我认同。 ————张佳玮 也就是“浮躁”。 我想，在正确的时间里，用正确的方法，专心投入地做正确的事，大学生活已经算是十分优雅了。]]></content>
      <categories>
        <category>方方说</category>
      </categories>
      <tags>
        <tag>专心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2进制转高进制压缩长度--《天才枪手》观后感]]></title>
    <url>%2F2%E8%BF%9B%E5%88%B6%E8%BD%AC%E9%AB%98%E8%BF%9B%E5%88%B6%E5%8E%8B%E7%BC%A9%E9%95%BF%E5%BA%A6-%E3%80%8A%E5%A4%A9%E6%89%8D%E6%9E%AA%E6%89%8B%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[天才枪手这部剧中，女主角提到的stic考试作弊计划之所以要引入“班克”参加，说是因为她背不下来50多道选择题，可以说间接导致了整个计划的失败。但是我突然想到，如果将ABCD四个选项整合为2进制，用00,01,10,11来代替，这样50多道选择题就会变成一个100多位由0和1组成的数。然后我们对这组数进行压缩处理，就会使长度逐渐变小，最终会相对容易记住并且被发现也基本不会被认为是在传答案。例如，我可以将4位2进制数分为一组，可以对应一个16进制的数（0-g），这样相当于，每两个答案可以合并为一个数字或字母，这样50多个答案会被压缩为20-30位字符，相当于将长度压缩为原来的1/2。女主正好可以记下。并且，在进行短暂的练习之后，可以保证看见两个选项立即写出对应的16进制字符（我就可以，hhhhh）。为什么不转换为更高位数的数字，我的解释是，效率不高。简而言之就是，转换为更高的位数并不能对字符的长度进行更加高效的压缩。2个选项有16种变化正好对应16个字符，而3个选项有64种变化，与之对应的是64进制，64进制包括了26个字母的大小写和0-9十个数字，以及“+”和“/”两个符号，转换的过程会花费大量的时间，并且字母的大小写记忆起来并不容易。我在开始想这个问题的时候，写了2转10再转36进制的字符位数，可以看出，最后依然为20多位，并且转换的过程相当复杂，并不适合考试这种环境。我可以对这100多位2进制数分组，每12个数为一组，将其转换为10进制，就会得到一个4位数（都选D时最大为4095），这样进行一次压缩之后，100多位数会变为30多位十进制的数，再将十进制的数字转换为36进制，以26个大写英文字母及0-9十个数字代替，每三组4位数为一大组转换为一个8位数（最大值为58523YLR），这样50多道选择题会被压缩为一个20位左右的数字加字母的组合。至于为什么这种方法没有比16进制取得更好的压缩效果，我的想法是：在这个举例中，并没有很好的利用进制内的所有数字，例如，在10进制中，最大只用到了4095，还有一大半的数字没有用上，在36进制中，更有6/7的排列没有用上，导致了压缩效率低下。如果按照上文充分利用高进制的排列组合，使用64进制，50多个选项就可以被压缩为17位左右。 总结： 2进制数转高进制压缩时，要尽量多利用到高进制中的排列顺序，这样的压缩效率才会提高。 在计算机中，存在将2进制数压缩为64进制的形式，称为base64编码，Base64是网络上最常见的用于传输8Bit字节码的编码方式之一。 考试作弊是不对的。]]></content>
      <categories>
        <category>方方说</category>
        <category>电影</category>
      </categories>
      <tags>
        <tag>天才枪手</tag>
        <tag>base64编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ubuntu16.04的vps上安装搭建ftp]]></title>
    <url>%2F%E5%9C%A8ubuntu16-04%E7%9A%84vps%E4%B8%8A%E5%AE%89%E8%A3%85%E6%90%AD%E5%BB%BAftp%2F</url>
    <content type="text"><![CDATA[由于身边设备包含种类过多，有Windows、Ubuntu、Android、iOS，有时候想要在四台设备间同步ppt，pdf，或者在Windows和Ubuntu上切换编译环境时用u盘拷贝文件步骤过于繁琐，且现有的一台服务器还没能充分利用资源，便萌生了在vps上再搭建一个ftp服务器的想法。我对于ftp服务器的要求就是：有一定安全性，禁止匿名访问，尽量走加密通道传输，使用账户密码登录然而百度上的教程经过我的测试大都不靠谱，于是自己Google摸索了一晚，找到了适合自己的搭建ftp的方法，在此分享并作为自己的备份。 1、安装vsftpd软件流行的FTP服务器端软件有：PureFTP，vsftpd,ProFTPD。考虑到租的服务器性能不高，我采用了轻量并且坑少的vsftpd。命令如下：sudo apt updatesudo apt install vsftpd安装完成后，需要对其进行一定的设置来使用。vilink123456789101112取消下列行首的#注释```write_enable=YES```（允许用户在ftp中的写入操作）```local_umask=022```（为用户增加相应的读写权限）```chroot_local_user=yes```（阻止访问除了用户文件夹意外的文件夹）在文件的末尾添加下列语句来开启消极模式：&lt;code&gt;allow_writeable_chroot=YESpasv_enable-YESpasv_min_port=40000pasv_max_port=40100&lt;/code&gt;之后保存退出编辑，重启vsftpd服务```service vsftpd restart 这时，ftp服务器就可以使用了，但是在21端口使用ftp登录是非常危险的，即使使用了账户密码，但传输文件很容易会被劫持，因此我在Google之后选择使用更为安全的sftp。 2、安装配置sftpsftp使用的是ssh文件传输协议，需要安装openssh-server,一般的vps服务器都预先安装过。安装过就可以跳过这一步。安装命令如下：apt install openssh-server```123安装完成之后我们需要为ftp新建一个用户。为了以后可能会添加用户，这里就创建一个ftpaccess用户组。```sudo groupadd ftpaccess 然后需要在/etc/ssh/sshd_config中修改一些参数。vilink123456789101112找到 **PasswordAuthentication**参数，若其=no，则将其注释掉，若为yes，就不用管。找到 **Subsystem sftp /usr/lib/openssh/sftp-server**将其注释掉。在文件最后添加下列语句：&lt;code&gt;Subsystem sftp internal-sftpMatch group ftpaccessChrootDirectory %hX11Forwarding noAllowTcpForwarding noForceCommand internal-sftp&lt;/code&gt;之后重启ssh服务```service ssh restart 下面开始创建访问sftp服务的用户创建用户xiaofangdyd,属于ftpaccess组sudo useradd -m xiaofangdyd -g ftpaccess -s /usr/bin/nologin(其中使用/usr/bin/nologin脚本来阻止ftp用户访问bash脚本，增加安全性)sudo passwd xiaofangdyd(设置密码)sudo chown root /home/xiaofangdyd(为相应文件夹赋予root权限)开启nologin脚本的开机访问sudo vi /etc/shells在最后添加如下行：/usr/bin/nologin最后在home文件夹创建一个用于下入文件的文件夹，并修改文件夹的所有者mkdir /home/xiaofangdyd/filessudo chown xiaofangdyd:ftpaccess /home/xiaofangdyd/files现在就可以通过sftp来向files文件夹上传并下载文件了。 在Windows和Linux操作端，推荐使用filezilla客户端版（filezilla Client）对ftp服务器进行访问。因为首先fz提供了对sftp登录的支持，最重要的是，由于简体中文版的Windows系统因为国家规定使用的是GBK字符编码，在ubuntu服务器以及linux上，默认使用的是utf-8全球通用编码，编码不同会导致中文文件名乱码。因此需要在fz中开启强制使用utf-8编码，才能保证文件之间的稳定传输。在iOS上，我使用的是FtpManager，同样使用sftp登录，强制使用utf-8字符编码。在Android上,我使用的是AndFTP，设置同上。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.11.26今天要考线代]]></title>
    <url>%2F2017-11-26%E4%BB%8A%E5%A4%A9%E8%A6%81%E8%80%83%E7%BA%BF%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[昨天是星期六，心中怀揣着对线性代数的恐惧和室友泡了一天的图书馆……下午一个人出来的时候突然觉得好冷，好像每次从图书馆走出来都是这样的吧。 吃完饭回图书馆之前，溜去校外买了一杯抹茶，旁边的小女孩看着我和大人说：“他在一个人买奶茶。”瞬间觉得抹茶好苦啊。 可能每个人一生中都会有那么一段，需要一个人度过的时光，在这段时光里，我们会学会与自己相处，去了解自己，认识自己，认识这个世界。 路上看到夕阳和一棵树共同构成了一幅异常和谐的场面，兴高采烈想要分享出去，打好了字配好了图，在打算发送状态的那一刻，又退出了状态发送。就当没看到过这棵树吧。 走在路上发现，听歌时没谁可想，空空落落的，也不是件好事。 现在想想，为什么上了大学，人们开始拼命寻找恋人，拉帮结派，还不是因为大家都孤独。 我走到阳台，吸着雾霾看天。繁星漫天，远处零散的几处霓虹灯。我想着自己，突然有点想哭。又过了一会，一阵风吹来。吹来一大片云，关掉了天上的星灯。学校的路灯早已熄灭，漆黑的夜里更加漆黑。也许它认为城市应该睡觉了，但是我还醒着。 在微博上看到这张图片，刚开始觉得这真是一个热爱生活自娱自乐的狗子。但细想这不就是孤独吗，一个人扮演两个人角色。现实有很多人跟这只狗狗一样，狗狗表现在肢体，我们表演在内心。 站在汹涌的人群中，看着人家两人嬉闹打笑。我捂着嘴巴看完，生怕发出一声狗叫。窗内灯光柔软 爱意浓浓， 窗外寒风凌厉，形单影只。外面太冷了，衣服有点单薄，我想回家了。]]></content>
      <categories>
        <category>方方说</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法--睡眠排序、面条排序、猴子排序 (非常严肃)]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%9D%A1%E7%9C%A0%E6%8E%92%E5%BA%8F%E3%80%81%E9%9D%A2%E6%9D%A1%E6%8E%92%E5%BA%8F%E3%80%81%E7%8C%B4%E5%AD%90%E6%8E%92%E5%BA%8F-%E9%9D%9E%E5%B8%B8%E4%B8%A5%E8%82%83%2F</url>
    <content type="text"><![CDATA[常见的排序算法–诸如快排、堆排或归并等——都是基于比较的，除了这种正统意义上的排序算法，最近了解了几种令人啼笑皆非的排序算法，与大家分享一下。 1、睡眠排序（sleep sort）这个算法可以说算是最强大的排序算法，他的时间复杂度为O(n)，空间复杂度为0 ！时间复杂度完爆了quick sort，空间复杂度完爆了hash，而且还是稳定的。c代码实现如下：原理主要是利用多线程，把接受的每一个参数分别放在不同的线程里面并在每个线程同时使用sleep函数，sleep的时间就是参数的值，这样的话利用“数值大的参数的线程sleep的时间更长”这个事实，数字小的值就被先打印出来了，从而达到从小到大排序的目的。简单来说就是对于[1,3,6,10]这个数组，让计算机在第1s输出1，在第3s输出3，第6s输出6，第10s输出10。不过这个方法有个致命的缺点，就是如果被排序的数字很大的话，花的时间也比较多。以提供的代码为例，如果参数是3, 1, 10000的话，那么输出结果在第一秒会输出1，第三秒会输出3，但是要在10000秒时才能输出10000。为了提高速度可以按比例缩短时间，比如把sleep那句改成sleep(this/10000)，但是也不能无限制缩小时间，当睡眠时间小于开启多线程的时间时，就会出现乱序。当然上面这段代码很粗略，有很多问题还没解决。比如： 搞不定负数。（可以用一个恒正的函数将输入映射成时间） 输入相近的数会有误差。（可以乘个适当的系数，放大数据间的差） 当输入的数据很多时，这些线程不能看作是同时启动的等等。 2、面条排序（Spaghetti Sort）意大利面条排序(Spaghetti Sort)的思路是，将输入分别对应到不同长度的面条上，每根面条的长度即为对应的数字的大小。比如，对于[1, 4, 2, 8, 9]这个输入，则分别做出长度为1cm、4cm、2cm、8cm、9cm的面条。然后，将这些面条的一头对齐，用手抓住，另一头向下。然后慢慢地将手向下垂直下降，第一个触碰到桌面的面条对应的数字则为最大的数字，第二个触碰到的就是第二大的，依次类推，代码没找到…看起来挺简单的，和睡眠排序差别不大，就不写了…. 3、猴子排序（Bogo Sort）如下关于猴子排序(Bogo Sort)的描述摘自维基百科： 在计算机科学中，Bogo排序（Bogo-Sort）是个既不实用又原始的排序算法，其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次。其名字源自Quantum bogodynamics，又称bozo sort、blort sort或猴子排序（参见无限猴子定理）。 所谓无限猴子定理，即是：让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。 猴子排序也是一样，原理就是随机打乱数组，检查是否排好序，若是，则输出，否则再次打乱，再检查……最佳情况的复杂度为O(n)，平均O(n*n!)，最坏可执行到世界末日。c++代码如下：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;//random需要的头文件using namespace std;const int maxn = 103;int n, a[maxn];bool Ordered() &#123; for (int i = 0; i + 1 &lt; n; ++ i) &#123; if (a[i] &gt; a[i + 1]) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; &#125; while (!Ordered()) &#123; random_shuffle(a, a + n); &#125; for (int i = 0; i &lt; n; ++ i) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125; 所以，这种排序算法，基本大家就在吹牛的时候说说就好了，写在代码里，基本上就是分分钟被打死的后果。 3.1、量子猴排(Quantum Bogo Sort)量子猴排可以算是概念上对猴子排序的一种优化：洗牌的时候，使用量子化随机排列。这样的话，我们在观测这组数之前，这组数的状态是叠加的，参照薛定谔的猫。通过这种量子化随机排列，我们划分出来了个平行宇宙。接下来，在某个宇宙A中，观测一下这组数，发现运气不好，没有排序好，那么我们就销毁掉这个宇宙。然后再看看其他宇宙的运气怎么样。终于，在一个宇宙Z中，发现刚好是排好序的数组。那么我们就保留这个宇宙。最后，没有被销毁的宇宙中，数组都是恰好一次被排好序的。对了，量子猴排的时间复杂度是O(n)！]]></content>
      <categories>
        <category>tools</category>
        <category>code</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>睡眠排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在服务器端使用一键安装ss脚本及线路优化]]></title>
    <url>%2F%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ss%E8%84%9A%E6%9C%AC%E5%8F%8A%E7%BA%BF%E8%B7%AF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[下载：常规版Windows客户端 ShadowsocksR版Windows客户端 安装：为了能有一个稳定的上网环境，以及某件事情的影响，萌生了想自己搭梯子的想法。最近的一个月一直在恶补这方面的知识，并自己动手实践，对shadowsocks的使用才初步入门，知道了在服务器端安装ss客户端的方法，总结下来，最为简单易用的是秋水逸冰的一键安装脚本本脚本适用于CentOS 6，7，Debian，Ubuntu系统，ss客户端对硬件资源的要求并不高，因此在选择服务器时如果没有其他需求的话，只用考虑网络带宽以及流量问题，这里需要注意的是，搭建的服务器相当于是本地访问和网站之间的桥梁，网站的数据包会先下载到服务器上，然后由服务器上传到本地客户端中，因此，服务器端使用的流量是本地流量的2倍，就好比你在购买服务器时，网站提示一个月有1000g的流量限制，当你在youtube上看500g的视频后，你的服务器端1000g流量其实已经用完了。服务器的购买并没有固定的推荐，每个地区的网络不同，运营商不同都会导致网速的差异，因此选择一个好的服务器很重要。我所在的西安电信使用digitalocean上提供的sfo的ubuntu服务器实测下载峰值可以达到2m/s，其他地区未知。购买及连接方法日后再谈，今天主要想记录下服务器的配置及优化。本文使用的是秋水逸冰的一键安装脚本，当在本地使用ssh命令（linux及mac os）或者xshell5（windows）连接上服务器的root用户后，依次运行以下3条命令。123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 之后脚本便自动执行，首先选择安装shadowsocks的版本，默认的1是常规，还有一个shadowsocksR版可供选择。然后脚本会提示进行shadowsocks的基本参数设置第一次是设置密码（如不设定，默认为 teddysun.com）然后是服务器端口（如不设定，默认为 8989）最后是选择加密方式（如不设定，默认为 aes-256-gcm）加密方式我一般选择为第7个 aes-256-cfb（因为其支持的客户端相对较多一点）安装完成后，脚本会提示： 12345678Congratulations, Shadowsocks-python server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 这时可以记下ip 远程端口 和密码在shadowsocks客户端上使用了。为了充分发挥服务器的网络性能，就需要对服务器的网络进行优化，最近Google 开源了其TCP BBR拥塞控制算法，并提交到了Linux内核。从4.9开始，Linux 内核已经用上了该算法。经过上机测试，有些机器的网速甚至可以提升好几个数量级。本次更新内核及开启bbr算法依旧使用的是秋水逸冰的脚本。在服务器root用户下，使用命令： --no-check-certificate&& chmod +x bbr.sh && ./bbr.sh```1234安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：```uname -r 查看内核版本，如果显示在4.13及以上说明ok了。这时服务器端的ss已经配置优化完成，脚本默认开启了ss的开机启动，因此服务器重启也不会有影响。 卸载：在root用户下，使用命令uninstall```12345## 使用命令：启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。Shadowsocks-Python 版：```/etc/init.d/shadowsocks-python start | stop | restart | status ShadowsocksR 版：start | stop | restart | status```123Shadowsocks-Go 版：```/etc/init.d/shadowsocks-go start | stop | restart | status Shadowsocks-libev 版：start | stop | restart | status```1234各版本默认配置文件位置Shadowsocks-Python 版：```/etc/shadowsocks-python/config.json ShadowsocksR 版：123Shadowsocks-Go 版：```/etc/shadowsocks-go/config.json Shadowsocks-libev 版：1234多用户多端口配置方法在root用户下，使用命令```vi /etc/shadowsocks.json e.g:1234567891011121314&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;&quot;8989&quot;:&quot;password0&quot;,&quot;9001&quot;:&quot;password1&quot;,&quot;9002&quot;:&quot;password2&quot;,&quot;9003&quot;:&quot;password3&quot;,&quot;9004&quot;:&quot;password4&quot;&#125;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;your_encryption_method&quot;,&quot;fast_open&quot;: false&#125; 参考链接https://teddysun.com/342.htmlhttps://teddysun.com/489.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>Google BBR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网址查询]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[校园卡转账（校园网）西农校园网自助服务系统（校园网）英语视听说网址（校园网）万有仓库代码托管平台麦田pt的ipv6网址（需要ipv6网）豆瓣电影 Top 250onedrive客户端（Windows7及以下）Visual Studio Code下载]]></content>
      <categories>
        <category>方方说</category>
      </categories>
      <tags>
        <tag>学校</tag>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
